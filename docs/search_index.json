[
["index.html", "sigminer: Genomic Alteration Signature Analysis in R Introduction Installation Issues or Suggestions Preparation Citation and LICENSE", " sigminer: Genomic Alteration Signature Analysis in R Shixiang Wang, ShanghaiTech University Xue-Song Liu, ShanghaiTech University last revised on 2020-03-16 Introduction Genomic alterations including single nucleotide substitution (SBS), copy number alteration (CNA), etc. are the major force for cancer initialization and development. Due to the specificity of molecular lesions caused by genomic alterations, we can generate characteristic alteration spectra, called ‘signature’. To illustrate the biological significance of genome alteration signatures, we show some well organized figures here. Figure 0.1: The illustration of SBS signature, fig source: https://www.nature.com/articles/nrg3729 Figure 0.2: The illustration of SBS signature (2), fig source: https://www.nature.com/articles/s41467-018-05228-y SBS signature is previously known as mutational signature. SBS signatures are well studied and related to single-strand changes, typically caused by defective DNA repair. Common etiologies contain aging, defective DNA mismatch repair, smoking, ultraviolet light exposure and APOBOE. Currently, all SBS signatures are summarized in COSMIC database, including two versions: v2 and v3. Recently, Alexandrov et al. (2020) extends the concept of mutational signature to three types of mutation: SBS, DBS and INDEL. Here, we use genomic alteration signature to refer any kind of mutation type can be used to generate signature. Figure 0.3: The illustration of copy number signatures, fig source: https://www.nature.com/articles/s41588-018-0212-y Copy number signatures are less studied and many works are still to be done. To study signatures, we created an easy-to-use and scalable toolkit for genomic alteration signature analysis and visualization in R. We named it sigminer (signature + miner). This tool can help users to extract, analyze and visualize signatures from genomic alteration records, thus providing new insight into cancer study. Currently, sigminer supports two types of signature: SBS signature in the form of 96 components Copy number signature by the method either from Macintyre et al. (2018) or from our group work. Installation The sigminer package can be installed from CRAN or Github: remotes::install_github(&quot;ShixiangWang/sigminer&quot;) Issues or Suggestions Any issue can be posted on GitHub issue, we will reply ASAP. We have plans to extend other mutational signatures (like INDEL and DBS) to sigminer or extend reading input from other softwares, contribution is welcome. Preparation To reproduce the examples shown in this manual, users should load the following packages firstly. sigminer is requred to have version &gt;= 1.0.0. library(sigminer) library(NMF) Current manual uses sigminer 1.0.0. More info about sigminer can be given as: hello() #&gt; Thanks for using &#39;sigminer&#39; package! #&gt; ========================================================================= #&gt; Version: 1.0.0 #&gt; #&gt; Project home : https://github.com/ShixiangWang/sigminer #&gt; Bug report : https://github.com/ShixiangWang/sigminer/issues #&gt; Documentation: https://shixiangwang.github.io/sigminer-doc/ #&gt; ========================================================================= #&gt; Citation and LICENSE If you use sigminer in academic field, please cite our work: Copy number signature analyses in prostate cancer reveal distinct etiologies and clinical outcomes, under submission The software is made available for non commercial research purposes only under the MIT. However, notwithstanding any provision of the MIT License, the software currently may not be used for commercial purposes without explicit written permission after contacting Shixiang Wang wangshx@shanghaitech.edu.cn or Xue-Song Liu liuxs@shanghaitech.edu.cn. MIT © 2019-2020 Shixiang Wang, Xue-Song Liu MIT © 2018 Geoffrey Macintyre MIT © 2018 Anand Mayakonda Cancer Biology Group @ShanghaiTech Research group led by Xue-Song Liu in ShanghaiTech University References "],
["part-signature-identification.html", "(PART) Signature Identification", " (PART) Signature Identification "],
["sbssig.html", "Chapter 1 SBS Signature Identification Read Data Tally Components Signature Extraction", " Chapter 1 SBS Signature Identification In this chapter, we will introduce how to identify SBS signatures from SBS records of variant calling data. The signature identification procedure has been divided into 3 steps: Read mutation data Tally components: classify SBS into 96 components and generate sample matrix Extract signatures: estimate signature number and identify signatures Read Data The input data should be in MAF format, it can be either a MAF file or a data.frame. There is a famous R/Bioconductor package Maftools (Mayakonda et al. 2018) for analyzing MAF data. Here, we use the example MAF file stored in Maftools as input and extract SBS signatures from the data. Make sure library(sigminer) before running the following code. laml.maf &lt;- system.file(&quot;extdata&quot;, &quot;tcga_laml.maf.gz&quot;, package = &quot;maftools&quot;, mustWork = TRUE) laml &lt;- read_maf(maf = laml.maf) #&gt; -Reading #&gt; -Validating #&gt; -Silent variants: 475 #&gt; -Summarizing #&gt; -Processing clinical data #&gt; --Missing clinical data #&gt; -Finished in 0.310s elapsed (0.190s cpu) laml #&gt; An object of class MAF #&gt; ID summary Mean Median #&gt; 1: NCBI_Build 37 NA NA #&gt; 2: Center genome.wustl.edu NA NA #&gt; 3: Samples 193 NA NA #&gt; 4: nGenes 1241 NA NA #&gt; 5: Frame_Shift_Del 52 0.271 0 #&gt; 6: Frame_Shift_Ins 91 0.474 0 #&gt; 7: In_Frame_Del 10 0.052 0 #&gt; 8: In_Frame_Ins 42 0.219 0 #&gt; 9: Missense_Mutation 1342 6.990 7 #&gt; 10: Nonsense_Mutation 103 0.536 0 #&gt; 11: Splice_Site 92 0.479 0 #&gt; 12: total 1732 9.021 9 The laml is a MAF object. The MAF class is exported from Maftools to sigminer. So laml can be directly use functions provided by Maftools. As a MAF object, the mutation records are stored in slot data and maf.silent. head(laml@data) #&gt; Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome Start_Position End_Position Strand #&gt; 1: ABCA10 10349 genome.wustl.edu 37 17 67170917 67170917 + #&gt; 2: ABCA4 24 genome.wustl.edu 37 1 94490594 94490594 + #&gt; 3: ABCB11 8647 genome.wustl.edu 37 2 169780250 169780250 + #&gt; 4: ABCC3 8714 genome.wustl.edu 37 17 48760974 48760974 + #&gt; 5: ABCF1 23 genome.wustl.edu 37 6 30554429 30554429 + #&gt; 6: ABCG4 64137 genome.wustl.edu 37 11 119031351 119031351 + #&gt; Variant_Classification Variant_Type Reference_Allele Tumor_Seq_Allele1 Tumor_Seq_Allele2 Tumor_Sample_Barcode #&gt; 1: Splice_Site SNP T T C TCGA-AB-2988 #&gt; 2: Missense_Mutation SNP C C T TCGA-AB-2869 #&gt; 3: Missense_Mutation SNP G G A TCGA-AB-3009 #&gt; 4: Missense_Mutation SNP C C T TCGA-AB-2887 #&gt; 5: Missense_Mutation SNP G G A TCGA-AB-2920 #&gt; 6: Missense_Mutation SNP A A G TCGA-AB-2934 #&gt; Protein_Change i_TumorVAF_WU i_transcript_name #&gt; 1: p.K960R 45.66000 NM_080282.3 #&gt; 2: p.R1517H 38.12000 NM_000350.2 #&gt; 3: p.A1283V 46.97218 NM_003742.2 #&gt; 4: p.P1271S 56.41000 NM_003786.1 #&gt; 5: p.G658S 40.95000 NM_001025091.1 #&gt; 6: p.Y567C 32.84000 NM_022169.1 head(laml@maf.silent) #&gt; Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome Start_Position End_Position Strand #&gt; 1: ABCC11 85320 genome.wustl.edu 37 16 48244997 48244997 + #&gt; 2: ACAN 176 genome.wustl.edu 37 15 89401084 89401084 + #&gt; 3: ACAT1 38 genome.wustl.edu 37 11 108009744 108009744 + #&gt; 4: ACCN2 41 genome.wustl.edu 37 12 50452780 50452780 + #&gt; 5: ACTA2 59 genome.wustl.edu 37 10 90695109 90695109 + #&gt; 6: ACTL9 284382 genome.wustl.edu 37 19 8808551 8808551 + #&gt; Variant_Classification Variant_Type Reference_Allele Tumor_Seq_Allele1 Tumor_Seq_Allele2 Tumor_Sample_Barcode #&gt; 1: Silent SNP G G A TCGA-AB-2830 #&gt; 2: Silent SNP C C T TCGA-AB-2898 #&gt; 3: Silent SNP T T G TCGA-AB-2887 #&gt; 4: Silent SNP C C G TCGA-AB-3009 #&gt; 5: Silent SNP C C T TCGA-AB-2973 #&gt; 6: Silent SNP G G A TCGA-AB-2936 #&gt; Protein_Change i_TumorVAF_WU i_transcript_name #&gt; 1: p.I490I 34.2700000 NM_032583.3 #&gt; 2: p.S1756S 38.3000000 NM_013227.2 #&gt; 3: p.T185T 49.0400000 NM_000019.3 #&gt; 4: p.L77L 48.1000000 NM_020039.2 #&gt; 5: p.P335P 0.2012072 NM_001613.1 #&gt; 6: p.F167F 46.1500000 NM_178525.3 The data slot contains non-silent variants, and the maf.silent slot contains silent variants. Default uses Variant Classifications with High/Moderate variant consequences as non-silent variants. http://asia.ensembl.org/Help/Glossary?id=535: “Frame_Shift_Del”, “Frame_Shift_Ins”, “Splice_Site”, “Translation_Start_Site”,“Nonsense_Mutation”, “Nonstop_Mutation”, “In_Frame_Del”,“In_Frame_Ins”, “Missense_Mutation” (see ?read_maf). If you want to change, please set vc_nonSyn option. Other slots in MAF object are summary data either by sample or gene/variant type etc. slotNames(laml) #&gt; [1] &quot;data&quot; &quot;variants.per.sample&quot; &quot;variant.type.summary&quot; #&gt; [4] &quot;variant.classification.summary&quot; &quot;gene.summary&quot; &quot;summary&quot; #&gt; [7] &quot;maf.silent&quot; &quot;clinical.data&quot; Tally Components According to 3-nucleotide context (mutated base, 5’ and 3’ adjacent bases) and base complementary pairing principle, we can divide all SBS mutations into 96 mutation types. We call each mutation type as a component here. This classification is based the six substitution subtypes: C&gt;A, C&gt;G, C&gt;T, T&gt;A, T&gt;C, and T&gt;G (all substitutions are referred to by the pyrimidine of the mutated Watson—Crick base pair). Further, each of the substitutions is examined by incorporating information on the bases immediately 5’ and 3’ to each mutated base generating 96 possible mutation types (6 types of substitution x 4 types of 5’ base x 4 types of 3’ base). We tally components in each sample, and generate a sample-by-component matrix. if (require(&quot;BSgenome.Hsapiens.UCSC.hg19&quot;)) { mt_tally &lt;- sig_tally( laml, ref_genome = &quot;BSgenome.Hsapiens.UCSC.hg19&quot;, prefix = &quot;chr&quot;, add = TRUE, useSyn = TRUE ) } else { message(&quot;Please install package &#39;BSgenome.Hsapiens.UCSC.hg19&#39; firstly!&quot;) } #&gt; Warning in maftools::trinucleotideMatrix(object, ref_genome = ref_genome, : Chromosome names in MAF must match chromosome names in reference genome. #&gt; Ignorinig 101 single nucleotide variants from missing chromosomes chr23 #&gt; -Extracting 5&#39; and 3&#39; adjacent bases #&gt; -Extracting +/- 20bp around mutated bases for background C&gt;T estimation #&gt; -Estimating APOBEC enrichment scores #&gt; --Performing one-way Fisher&#39;s test for APOBEC enrichment #&gt; ---APOBEC related mutations are enriched in 3.315 % of samples (APOBEC enrichment score &gt; 2 ; 6 of 181 samples) #&gt; -Creating mutation matrix #&gt; --matrix of dimension 188x96 mt_tally$nmf_matrix #&gt; A[C&gt;A]A A[C&gt;A]C A[C&gt;A]G A[C&gt;A]T C[C&gt;A]A C[C&gt;A]C C[C&gt;A]G C[C&gt;A]T G[C&gt;A]A G[C&gt;A]C G[C&gt;A]G G[C&gt;A]T T[C&gt;A]A #&gt; TCGA-AB-2802 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2803 0 2 0 0 0 1 0 0 0 0 0 0 0 #&gt; TCGA-AB-2804 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2805 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2806 0 0 0 0 0 0 0 0 1 0 1 0 0 #&gt; TCGA-AB-2807 0 0 1 0 0 1 0 0 0 1 0 0 0 #&gt; TCGA-AB-2808 0 0 0 0 0 0 1 0 0 0 0 0 0 #&gt; TCGA-AB-2809 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2810 0 0 0 0 0 1 0 0 0 0 0 0 0 #&gt; TCGA-AB-2812 0 1 0 0 0 0 0 0 0 0 0 1 1 #&gt; T[C&gt;A]C T[C&gt;A]G T[C&gt;A]T A[C&gt;G]A A[C&gt;G]C A[C&gt;G]G A[C&gt;G]T C[C&gt;G]A C[C&gt;G]C C[C&gt;G]G C[C&gt;G]T G[C&gt;G]A G[C&gt;G]C #&gt; TCGA-AB-2802 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2803 0 0 0 0 0 0 0 1 0 0 0 1 0 #&gt; TCGA-AB-2804 0 0 0 0 0 0 0 0 0 1 0 0 0 #&gt; TCGA-AB-2805 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2806 0 0 1 0 0 1 0 0 0 1 0 0 0 #&gt; TCGA-AB-2807 1 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2808 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2809 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2810 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2812 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; G[C&gt;G]G G[C&gt;G]T T[C&gt;G]A T[C&gt;G]C T[C&gt;G]G T[C&gt;G]T A[C&gt;T]A A[C&gt;T]C A[C&gt;T]G A[C&gt;T]T C[C&gt;T]A C[C&gt;T]C C[C&gt;T]G #&gt; TCGA-AB-2802 0 0 0 0 0 0 0 0 1 0 1 0 1 #&gt; TCGA-AB-2803 0 0 0 0 0 0 2 0 2 0 0 0 1 #&gt; TCGA-AB-2804 0 0 0 0 0 0 1 0 2 0 0 0 1 #&gt; TCGA-AB-2805 0 0 0 0 0 0 0 0 3 1 0 0 4 #&gt; TCGA-AB-2806 0 0 0 0 1 0 0 0 1 0 0 0 2 #&gt; TCGA-AB-2807 1 0 0 0 0 0 0 1 4 2 0 0 4 #&gt; TCGA-AB-2808 0 0 0 0 0 0 0 2 2 0 0 0 1 #&gt; TCGA-AB-2809 0 0 0 0 0 0 0 0 1 0 0 0 0 #&gt; TCGA-AB-2810 0 0 0 0 0 0 0 0 0 0 0 1 5 #&gt; TCGA-AB-2812 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; C[C&gt;T]T G[C&gt;T]A G[C&gt;T]C G[C&gt;T]G G[C&gt;T]T T[C&gt;T]A T[C&gt;T]C T[C&gt;T]G T[C&gt;T]T A[T&gt;A]A A[T&gt;A]C A[T&gt;A]G A[T&gt;A]T #&gt; TCGA-AB-2802 1 0 0 1 1 1 0 0 0 0 0 1 0 #&gt; TCGA-AB-2803 1 0 0 1 1 0 0 1 0 0 0 0 0 #&gt; TCGA-AB-2804 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2805 0 0 0 1 1 0 1 0 0 0 0 0 0 #&gt; TCGA-AB-2806 0 0 0 3 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2807 1 0 1 5 0 1 1 0 0 0 0 0 0 #&gt; TCGA-AB-2808 0 0 0 2 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2809 0 0 0 2 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2810 0 0 1 0 0 1 1 1 0 0 0 0 0 #&gt; TCGA-AB-2812 0 0 0 0 1 0 0 0 1 0 0 0 0 #&gt; C[T&gt;A]A C[T&gt;A]C C[T&gt;A]G C[T&gt;A]T G[T&gt;A]A G[T&gt;A]C G[T&gt;A]G G[T&gt;A]T T[T&gt;A]A T[T&gt;A]C T[T&gt;A]G T[T&gt;A]T A[T&gt;C]A #&gt; TCGA-AB-2802 0 0 1 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2803 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2804 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2805 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2806 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2807 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2808 0 0 0 0 0 0 0 0 0 0 0 0 1 #&gt; TCGA-AB-2809 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2810 0 0 0 0 0 0 0 0 0 0 0 0 1 #&gt; TCGA-AB-2812 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; A[T&gt;C]C A[T&gt;C]G A[T&gt;C]T C[T&gt;C]A C[T&gt;C]C C[T&gt;C]G C[T&gt;C]T G[T&gt;C]A G[T&gt;C]C G[T&gt;C]G G[T&gt;C]T T[T&gt;C]A T[T&gt;C]C #&gt; TCGA-AB-2802 0 0 0 0 0 1 0 0 0 0 0 0 0 #&gt; TCGA-AB-2803 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2804 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2805 0 1 0 0 0 0 0 0 0 0 0 0 1 #&gt; TCGA-AB-2806 0 0 0 0 1 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2807 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2808 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2809 0 0 0 0 0 0 1 0 0 0 0 0 0 #&gt; TCGA-AB-2810 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2812 0 0 1 1 0 0 0 0 0 0 0 0 0 #&gt; T[T&gt;C]G T[T&gt;C]T A[T&gt;G]A A[T&gt;G]C A[T&gt;G]G A[T&gt;G]T C[T&gt;G]A C[T&gt;G]C C[T&gt;G]G C[T&gt;G]T G[T&gt;G]A G[T&gt;G]C G[T&gt;G]G #&gt; TCGA-AB-2802 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2803 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2804 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2805 0 0 0 0 0 0 0 0 0 1 0 0 0 #&gt; TCGA-AB-2806 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2807 0 0 0 0 0 0 0 1 0 0 0 0 0 #&gt; TCGA-AB-2808 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2809 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2810 0 1 0 0 0 0 0 0 0 0 0 0 0 #&gt; TCGA-AB-2812 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; G[T&gt;G]T T[T&gt;G]A T[T&gt;G]C T[T&gt;G]G T[T&gt;G]T #&gt; TCGA-AB-2802 0 0 0 0 0 #&gt; TCGA-AB-2803 0 0 0 0 0 #&gt; TCGA-AB-2804 0 0 0 0 0 #&gt; TCGA-AB-2805 0 0 0 0 0 #&gt; TCGA-AB-2806 0 0 0 0 0 #&gt; TCGA-AB-2807 0 0 0 0 0 #&gt; TCGA-AB-2808 0 0 0 0 0 #&gt; TCGA-AB-2809 0 0 0 0 0 #&gt; TCGA-AB-2810 0 0 0 0 0 #&gt; TCGA-AB-2812 0 0 1 0 0 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 178 rows ] We use notion left[ref&gt;mut]right to mark each component, e.g. C[T&gt;G]A means a base T with 5’ adjacent base C and 3’ adjacent base A is mutated to base G. If you have used signature extraction feature in Maftools, you may feel familiar. Currently, Maftools is the backend for read_maf() and sig_tally for SBS mutation. Signature Extraction There are two methods can be used to implement signature extraction. Firstly estimate signature number and then extract signatures. This method is powered by NMF package (Gaujoux and Seoighe 2010). Auto-extract signatures by automatic relevance determination technique in nonnegative matrix factorization (Tan and Févotte 2012), the code is implemented by SignatureAnalyzer (Kim et al. 2016) and exported to sigminer. Method 1: Estimate signature number To estimate signature number, we firstly run NMF for multiple times and calculate some measures from the results, then select the best signature number base the measure vs. signature number plot. This is done by sig_estimate() function. Let’s try signature number 2-5. For simplicity, we just run NMF twice for each signature number. We use 4 cores to speed up the computation. mt_est &lt;- sig_estimate(mt_tally$nmf_matrix, range = 2:5, nrun = 2, use_random = TRUE, cores = 4, pConstant = 1e-13, verbose = TRUE ) #&gt; Compute NMF rank= 2 ... + measures ... OK #&gt; Compute NMF rank= 3 ... + measures ... OK #&gt; Compute NMF rank= 4 ... + measures ... OK #&gt; Compute NMF rank= 5 ... + measures ... OK #&gt; Estimation of rank based on observed data. #&gt; method seed rng metric rank sparseness.basis sparseness.coef rss evar silhouette.coef silhouette.basis #&gt; 2 brunet random 1 KL 2 0.6370458 0.5971855 1810.435 0.4015091 1.0000000 1.0000000 #&gt; 3 brunet random 1 KL 3 0.6372400 0.6743758 1754.146 0.4201171 0.7649832 0.8266818 #&gt; 4 brunet random 2 KL 4 0.7210895 0.6237914 1630.012 0.4611532 0.6076863 0.7796580 #&gt; 5 brunet random 2 KL 5 0.7823037 0.5983197 1533.242 0.4931432 0.5177984 0.7674282 #&gt; residuals niter cpu cpu.all nrun cophenetic dispersion silhouette.consensus #&gt; 2 2801.391 1050 NA NA 2 0.8936413 0.5951222 0.7212555 #&gt; 3 2642.752 1490 NA NA 2 0.8654979 0.6343368 0.6409380 #&gt; 4 2471.362 2000 NA NA 2 0.8004145 0.6614418 0.4680241 #&gt; 5 2348.765 2000 NA NA 2 0.8312824 0.7230081 0.5746573 #&gt; Generating random matrix and run NMF... #&gt; Compute NMF rank= 2 ... + measures ... OK #&gt; Compute NMF rank= 3 ... + measures ... OK #&gt; Compute NMF rank= 4 ... + measures ... OK #&gt; Compute NMF rank= 5 ... + measures ... OK #&gt; Estimation of rank based on random data. #&gt; method seed rng metric rank sparseness.basis sparseness.coef rss evar silhouette.coef silhouette.basis #&gt; 2 brunet random 1 KL 2 0.2494534 0.6045842 2661.185 0.1202694 1.0000000 1.0000000 #&gt; 3 brunet random 2 KL 3 0.3907124 0.6493613 2589.416 0.1439948 0.7777385 0.8022393 #&gt; 4 brunet random 2 KL 4 0.4620419 0.6869145 2557.646 0.1544973 0.7018059 0.7010735 #&gt; 5 brunet random 1 KL 5 0.5198287 0.6905379 2508.413 0.1707726 0.6186418 0.6924856 #&gt; residuals niter cpu cpu.all nrun cophenetic dispersion silhouette.consensus #&gt; 2 4154.801 2000 NA NA 2 0.8698443 0.5183341 0.6746446 #&gt; 3 3884.292 1620 NA NA 2 0.8158685 0.5601517 0.5902376 #&gt; 4 3712.658 2000 NA NA 2 0.7622900 0.6370530 0.4329954 #&gt; 5 3549.757 2000 NA NA 2 0.7941740 0.7210842 0.4579933 We can show signature number survey for different measures by show_sig_number_survey2(). ## You can also select the measures to show ## by &#39;what&#39; option show_sig_number_survey2(mt_est$survey, mt_est$survey.random) For the details of all the measures above, please read Gaujoux and Seoighe (2010) and vignette of R package NMF. Typically, measure cophenetic is used for determing the signature number. We can easily generate an elbow plot with functionshow_sig_number_survey()`. show_sig_number_survey(mt_est$survey, right_y = NULL) Cophenetic indicates the robustness of consensus matrix clustering. In this situation, 2 or 3 is good. The most common approach is to use the cophenetic correlation coefficient. Brunet et al. suggested choosing the smallest value of r for which this coefficient starts decreasing. (Gaujoux and Seoighe 2010) However, there are no gold standard to determine the signature number. Sometimes, you should consider multiple measures. Remember, the most important thing is that you should have a good biological explanation for each signature. The best solution in study may not be the best solution in math. Method 1: Extract signatures After selecting a proper signature, you can now extract signatures. In general, use 30~50 NMF runs will get a robust result. mt_sig &lt;- sig_extract(mt_tally$nmf_matrix, n_sig = 3, nrun = 10, cores = 4, pConstant = 1e-13 ) Method 2: Auto-extract If you have no idea to select a optimal signature number from technologies above, you can try auto-extract feature here. mt_sig &lt;- sig_auto_extract(mt_tally$nmf_matrix, K0 = 10, nrun = 5) #&gt; Select Run 2, which K = 3 as best solution. References "],
["cnsig.html", "Chapter 2 Copy Number Signature Identification Introduction Read Data Tally Components Signature Extraction", " Chapter 2 Copy Number Signature Identification Introduction Unlike several mutation types presented in current COSMIC database for generating mutational signatures, it is hard to represent copy number features and generate the matrix for NMF decomposition. Macintyre et al. (2018) created a new method to generate the matrix for extracting signature by non-negative matrix factorization (NMF) algorithm. The steps are: derive 6 copy number features from absolute copy number profile apply mixture modelling to breakdown each feature distribution into mixtures of Gaussian or mixtures of Poisson distributions generate a sample-by-component matrix representing the sum of posterior probabilities of each copy-number event being assigned to each component. Based on previous work, our group devised a new method which discards the statistical modeling and create a fixed number of predefined components from 8 copy number features to generate the matrix as the input of NMF, it is easier to reproduce the result, apply to different cancer types and compare results. To test if the method would works, we applied it to prostate cancer and successfully identified 5 copy number signatures. Currently, there are few studies focus on copy number signatures and no reference signature database for matching and explaining the etiologies. If you study them, you should do extra work to explore and validate them. Furthermore, the input absolute copy number data may be generated by different methods and platforms, it is normal that the contribution of some copy number feature components varies a little and result in relatively lower signature similarity when comparing different cohorts or different copy number profile generation methods. Read Data Tally Components Signature Extraction References "],
["part-object-visualization.html", "(PART) Object Visualization", " (PART) Object Visualization "],
["cnobject.html", "Chapter 3 CopyNumber Object Profile Distribution", " Chapter 3 CopyNumber Object Profile Distribution "],
["sigobject.html", "Chapter 4 Signature Object Signature Profile Exposure Profile", " Chapter 4 Signature Object Signature Profile Exposure Profile "],
["part-signature-analysis-and-visualization.html", "(PART) Signature Analysis and Visualization", " (PART) Signature Analysis and Visualization "],
["association-analysis.html", "Chapter 5 Association Analysis and Visualization", " Chapter 5 Association Analysis and Visualization "],
["group-analysis.html", "Chapter 6 Group Analysis and Visualization Group Generation Group Comparison Analysis Group Visualization", " Chapter 6 Group Analysis and Visualization Group Generation Group Comparison Analysis Group Visualization "],
["part-others.html", "(PART) Others", " (PART) Others "],
["datasets.html", "Chapter 7 Datasets 7.1 Chromosome Size", " Chapter 7 Datasets 7.1 Chromosome Size "],
["references.html", "References", " References Alexandrov, Ludmil B, Jaegil Kim, Nicholas J Haradhvala, Mi Ni Huang, Alvin Wei Tian Ng, Yang Wu, Arnoud Boot, et al. 2020. “The Repertoire of Mutational Signatures in Human Cancer.” Nature 578 (7793): 94–101. Gaujoux, Renaud, and Cathal Seoighe. 2010. “A Flexible R Package for Nonnegative Matrix Factorization.” BMC Bioinformatics 11 (1): 367. Kim, Jaegil, Kent W Mouw, Paz Polak, Lior Z Braunstein, Atanas Kamburov, Grace Tiao, David J Kwiatkowski, et al. 2016. “Somatic Ercc2 Mutations Are Associated with a Distinct Genomic Signature in Urothelial Tumors.” Nature Genetics 48 (6): 600. Macintyre, Geoff, Teodora E Goranova, Dilrini De Silva, Darren Ennis, Anna M Piskorz, Matthew Eldridge, Daoud Sie, et al. 2018. “Copy Number Signatures and Mutational Processes in Ovarian Carcinoma.” Nature Genetics 50 (9): 1262–70. Mayakonda, Anand, De-Chen Lin, Yassen Assenov, Christoph Plass, and H Phillip Koeffler. 2018. “Maftools: Efficient and Comprehensive Analysis of Somatic Variants in Cancer.” Genome Research 28 (11): 1747–56. Tan, Vincent YF, and Cédric Févotte. 2012. “Automatic Relevance Determination in Nonnegative Matrix Factorization with the/Spl Beta/-Divergence.” IEEE Transactions on Pattern Analysis and Machine Intelligence 35 (7): 1592–1605. "]
]
