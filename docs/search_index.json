[
["index.html", "Sigminer: A Scalable Toolkit to Extract, Analyze and Visualize Mutational Signatures Chapter 1 Introduction 1.1 Biological Significance of Mutational Signature 1.2 Sigminer 1.3 Installation 1.4 Issues or Suggestions 1.5 Preparation 1.6 Overview of Contents 1.7 Citation and LICENSE", " Sigminer: A Scalable Toolkit to Extract, Analyze and Visualize Mutational Signatures Shixiang Wang, ShanghaiTech University Xue-Song Liu, ShanghaiTech University last revised on 2020-06-22 Chapter 1 Introduction Genomic alterations including single nucleotide substitution (SBS), copy number alteration (CNA), etc. are the major force for cancer initialization and development. Due to the specificity of molecular lesions caused by genomic alterations, we can generate characteristic alteration spectra, called mutational signature. 1.1 Biological Significance of Mutational Signature To illustrate the biological significance of mutational signatures, we show some well organized figures here. Figure 1.1: The illustration of SBS signature, fig source: https://www.nature.com/articles/nrg3729 Figure 1.2: The illustration of SBS signature (2), fig source: https://www.nature.com/articles/s41467-018-05228-y SBS signature is a famous type of mutational signature. SBS signatures are well studied and related to single-strand changes, typically caused by defective DNA repair. Common etiologies contain aging, defective DNA mismatch repair, smoking, ultraviolet light exposure and APOBEC. Currently, all SBS signatures are summarized in COSMIC database, including two versions: v2 and v3. Recently, Alexandrov et al. (2020) extends the concept of mutational signature to three types of alteration: SBS, DBS and INDEL. All reported common signatures are recorded in COSMIC (https://cancer.sanger.ac.uk/cosmic/signatures/), so we usually call them COSMIC signatures. Figure 1.3: The illustration of copy number signatures, fig source: https://www.nature.com/articles/s41588-018-0212-y Copy number signatures are less studied and many works are still to be done. The introduction is described in Chapter 3. 1.2 Sigminer Here, we present an easy-to-use and scalable toolkit for mutational signature analysis and visualization in R. We named it sigminer (signature + miner). This tool can help users to extract, analyze and visualize signatures from genomic alteration records, thus providing new insight into cancer study. Currently, sigminer supports four types of signature: SBS signature in the form of 96 (6, 24, 384, 1536 and 6144) components. DBS signature in the form of 78 (186) components. ID (INDEL) signature in the form of 83 (28) components. Copy number signature by the method either from Macintyre et al. (2018) or from our group work. 1.3 Installation The stable release version of sigminer package can be installed from the CRAN: install.packages(&quot;sigminer&quot;, dependencies = TRUE) # Or BiocManager::install(&quot;sigminer&quot;, dependencies = TRUE) Set dependencies = TRUE is recommended because many packages are required for full features in sigminer. The development version of sigminer package can be installed from Github: # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;ShixiangWang/sigminer&quot;, dependencies = TRUE) 1.4 Issues or Suggestions Any issue or suggestion can be posted on GitHub issue, we will reply ASAP. Any pull requrest is welcome. 1.5 Preparation To reproduce the examples shown in this manual, users should load the following packages firstly. sigminer is requred to have version &gt;= 1.0.0. library(sigminer) #&gt; sigminer version 1.0.7, run hello() to see usage and citation. library(NMF) #&gt; 载入需要的程辑包：pkgmaker #&gt; 载入需要的程辑包：registry #&gt; 载入需要的程辑包：rngtools #&gt; 载入需要的程辑包：cluster #&gt; NMF - BioConductor layer [OK] | Shared memory capabilities [NO: bigmemory] | Cores 7/8 #&gt; To enable shared memory capabilities, try: install.extras(&#39; #&gt; NMF #&gt; &#39;) Current manual uses sigminer 1.0.7. More info about sigminer can be given as: hello() #&gt; Thanks for using &#39;sigminer&#39; package! #&gt; ========================================================================= #&gt; Version: 1.0.7 #&gt; Run citation(&#39;sigminer&#39;) to see how to cite sigminer in publications. #&gt; #&gt; Project home : https://github.com/ShixiangWang/sigminer #&gt; Bug report : https://github.com/ShixiangWang/sigminer/issues #&gt; Documentation: https://shixiangwang.github.io/sigminer-doc/ #&gt; ========================================================================= #&gt; 1.6 Overview of Contents The contents of this manual have been divided into 4 sections: Common workflow. de novo signature discovery. single sample exposure quantification. subtype prediction. Target visualization. copy number profile. copy number distribution. catalogue profile. signature profile. exposure profile. … Universal analysis. association analysis. group analysis. Other utilities. 1.7 Citation and LICENSE citation(&quot;sigminer&quot;) #&gt; #&gt; To cite sigminer in publications use: #&gt; #&gt; Wang, Shixiang, et al. &quot;Copy number signature analyses in prostate cancer reveal distinct etiologies and clinical outcomes&quot; #&gt; medRxiv (2020). #&gt; #&gt; A BibTeX entry for LaTeX users is #&gt; #&gt; @Article{, #&gt; title = {Copy number signature analyses in prostate cancer reveal distinct etiologies and clinical outcomes}, #&gt; author = {Shixiang Wang and Huimin Li and Minfang Song and Zaoke He and Tao Wu and Xuan Wang and Ziyu Tao and Kai Wu and Xue-Song Liu}, #&gt; journal = {medRxiv}, #&gt; year = {2020}, #&gt; url = {https://www.medrxiv.org/content/early/2020/04/29/2020.04.27.20082404}, #&gt; } The software is made available for non commercial research purposes only under the MIT. However, notwithstanding any provision of the MIT License, the software currently may not be used for commercial purposes without explicit written permission after contacting Shixiang Wang wangshx@shanghaitech.edu.cn or Xue-Song Liu liuxs@shanghaitech.edu.cn. MIT © 2019-2020 Shixiang Wang, Xue-Song Liu MIT © 2018 Geoffrey Macintyre MIT © 2018 Anand Mayakonda Cancer Biology Group @ShanghaiTech Research group led by Xue-Song Liu in ShanghaiTech University References "],
["sbssig.html", "Chapter 2 COSMIC Signature Identification 2.1 Read Data 2.2 Tally Components 2.3 Extract Signatures 2.4 Match Signatures 2.5 Operate Signature", " Chapter 2 COSMIC Signature Identification In this chapter, we will introduce how to identify COSMIC signatures from records of variant calling data. The COSMIC signatures include three type of signatures: SBS, DBS and ID (short for INDEL). The signature identification procedure has been divided into 3 steps: Read mutation data. Tally components: for SBS, it means classifying SBS records into 96 components (the most common case) and generate sample matrix. Extract signatures: estimate signature number and identify signatures. 2.1 Read Data The input data should be in MAF format, it can be either a MAF file or a data.frame. There is a famous R/Bioconductor package Maftools (Mayakonda et al. 2018) for analyzing MAF data. Here, we use the example MAF file stored in Maftools as input and extract SBS signatures from the data. Make sure library(sigminer) before running the following code. laml.maf &lt;- system.file(&quot;extdata&quot;, &quot;tcga_laml.maf.gz&quot;, package = &quot;maftools&quot;, mustWork = TRUE) laml &lt;- read_maf(maf = laml.maf) #&gt; -Reading #&gt; -Validating #&gt; -Silent variants: 475 #&gt; -Summarizing #&gt; -Processing clinical data #&gt; --Missing clinical data #&gt; -Finished in 0.338s elapsed (0.321s cpu) laml #&gt; An object of class MAF #&gt; ID summary Mean Median #&gt; 1: NCBI_Build 37 NA NA #&gt; 2: Center genome.wustl.edu NA NA #&gt; 3: Samples 193 NA NA #&gt; 4: nGenes 1241 NA NA #&gt; 5: Frame_Shift_Del 52 0.269 0 #&gt; 6: Frame_Shift_Ins 91 0.472 0 #&gt; 7: In_Frame_Del 10 0.052 0 #&gt; 8: In_Frame_Ins 42 0.218 0 #&gt; 9: Missense_Mutation 1342 6.953 7 #&gt; 10: Nonsense_Mutation 103 0.534 0 #&gt; 11: Splice_Site 92 0.477 0 #&gt; 12: total 1732 8.974 9 The laml is a MAF object. The MAF class is exported from Maftools to sigminer. So laml can be directly use functions provided by Maftools. As a MAF object, the mutation records are stored in slot data and maf.silent. head(laml@data) #&gt; Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome Start_Position End_Position Strand Variant_Classification Variant_Type #&gt; 1: ABCA10 10349 genome.wustl.edu 37 17 67170917 67170917 + Splice_Site SNP #&gt; 2: ABCA4 24 genome.wustl.edu 37 1 94490594 94490594 + Missense_Mutation SNP #&gt; 3: ABCB11 8647 genome.wustl.edu 37 2 169780250 169780250 + Missense_Mutation SNP #&gt; 4: ABCC3 8714 genome.wustl.edu 37 17 48760974 48760974 + Missense_Mutation SNP #&gt; 5: ABCF1 23 genome.wustl.edu 37 6 30554429 30554429 + Missense_Mutation SNP #&gt; 6: ABCG4 64137 genome.wustl.edu 37 11 119031351 119031351 + Missense_Mutation SNP #&gt; Reference_Allele Tumor_Seq_Allele1 Tumor_Seq_Allele2 Tumor_Sample_Barcode Protein_Change i_TumorVAF_WU i_transcript_name #&gt; 1: T T C TCGA-AB-2988 p.K960R 45.66000 NM_080282.3 #&gt; 2: C C T TCGA-AB-2869 p.R1517H 38.12000 NM_000350.2 #&gt; 3: G G A TCGA-AB-3009 p.A1283V 46.97218 NM_003742.2 #&gt; 4: C C T TCGA-AB-2887 p.P1271S 56.41000 NM_003786.1 #&gt; 5: G G A TCGA-AB-2920 p.G658S 40.95000 NM_001025091.1 #&gt; 6: A A G TCGA-AB-2934 p.Y567C 32.84000 NM_022169.1 head(laml@maf.silent) #&gt; Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome Start_Position End_Position Strand Variant_Classification Variant_Type #&gt; 1: ABCC11 85320 genome.wustl.edu 37 16 48244997 48244997 + Silent SNP #&gt; 2: ACAN 176 genome.wustl.edu 37 15 89401084 89401084 + Silent SNP #&gt; 3: ACAT1 38 genome.wustl.edu 37 11 108009744 108009744 + Silent SNP #&gt; 4: ACCN2 41 genome.wustl.edu 37 12 50452780 50452780 + Silent SNP #&gt; 5: ACTA2 59 genome.wustl.edu 37 10 90695109 90695109 + Silent SNP #&gt; 6: ACTL9 284382 genome.wustl.edu 37 19 8808551 8808551 + Silent SNP #&gt; Reference_Allele Tumor_Seq_Allele1 Tumor_Seq_Allele2 Tumor_Sample_Barcode Protein_Change i_TumorVAF_WU i_transcript_name #&gt; 1: G G A TCGA-AB-2830 p.I490I 34.2700000 NM_032583.3 #&gt; 2: C C T TCGA-AB-2898 p.S1756S 38.3000000 NM_013227.2 #&gt; 3: T T G TCGA-AB-2887 p.T185T 49.0400000 NM_000019.3 #&gt; 4: C C G TCGA-AB-3009 p.L77L 48.1000000 NM_020039.2 #&gt; 5: C C T TCGA-AB-2973 p.P335P 0.2012072 NM_001613.1 #&gt; 6: G G A TCGA-AB-2936 p.F167F 46.1500000 NM_178525.3 The data slot contains non-silent variants, and the maf.silent slot contains silent variants. Default uses Variant Classifications with High/Moderate variant consequences as non-silent variants. http://asia.ensembl.org/Help/Glossary?id=535: “Frame_Shift_Del”, “Frame_Shift_Ins”, “Splice_Site”, “Translation_Start_Site”,“Nonsense_Mutation”, “Nonstop_Mutation”, “In_Frame_Del”,“In_Frame_Ins”, “Missense_Mutation” (see ?read_maf). If you want to change, please set vc_nonSyn option. Other slots in MAF object are summary data either by sample or gene/variant type etc. slotNames(laml) #&gt; [1] &quot;data&quot; &quot;variants.per.sample&quot; &quot;variant.type.summary&quot; &quot;variant.classification.summary&quot; #&gt; [5] &quot;gene.summary&quot; &quot;summary&quot; &quot;maf.silent&quot; &quot;clinical.data&quot; 2.2 Tally Components 2.2.1 The most common 96 components According to 3-nucleotide context (mutated base, 5’ and 3’ adjacent bases) and base complementary pairing principle, we can divide all SBS mutations into 96 mutation types. We call each mutation type as a component here. This classification is based the six substitution subtypes: C&gt;A, C&gt;G, C&gt;T, T&gt;A, T&gt;C, and T&gt;G (all substitutions are referred to by the pyrimidine of the mutated Watson—Crick base pair). Further, each of the substitutions is examined by incorporating information on the bases immediately 5’ and 3’ to each mutated base generating 96 possible mutation types (6 types of substitution x 4 types of 5’ base x 4 types of 3’ base). We tally components in each sample, and generate a sample-by-component matrix. mt_tally &lt;- sig_tally( laml, ref_genome = &quot;BSgenome.Hsapiens.UCSC.hg19&quot;, useSyn = TRUE ) #&gt; ℹ [2020-06-22 14:31:16]: Started. #&gt; #&gt; 载入程辑包：&#39;S4Vectors&#39; #&gt; The following object is masked from &#39;package:NMF&#39;: #&gt; #&gt; nrun #&gt; The following object is masked from &#39;package:pkgmaker&#39;: #&gt; #&gt; new2 #&gt; The following object is masked from &#39;package:base&#39;: #&gt; #&gt; expand.grid #&gt; #&gt; 载入程辑包：&#39;Biostrings&#39; #&gt; The following object is masked from &#39;package:base&#39;: #&gt; #&gt; strsplit #&gt; ✓ [2020-06-22 14:31:22]: Reference genome loaded. #&gt; ✓ [2020-06-22 14:31:22]: Variants from MAF object queried. #&gt; ✓ [2020-06-22 14:31:22]: Chromosome names checked. #&gt; ✓ [2020-06-22 14:31:22]: Sex chromosomes properly handled. #&gt; ✓ [2020-06-22 14:31:22]: Variant start and end position checked. #&gt; ✓ [2020-06-22 14:31:22]: Variant data for matrix generation preprocessed. #&gt; ℹ [2020-06-22 14:31:22]: SBS matrix generation - start. #&gt; ℹ [2020-06-22 14:31:22]: Extracting 5&#39; and 3&#39; adjacent bases. #&gt; ℹ [2020-06-22 14:31:24]: Extracting +/- 20bp around mutated bases for background C&gt;T estimation. #&gt; ℹ [2020-06-22 14:31:25]: Estimating APOBEC enrichment scores. #&gt; ℹ [2020-06-22 14:31:25]: Performing one-way Fisher&#39;s test for APOBEC enrichment. #&gt; ✓ [2020-06-22 14:31:25]: APOBEC related mutations are enriched in 3.297% of samples (APOBEC enrichment score &gt; 2; 6 of 182 samples) #&gt; ℹ [2020-06-22 14:31:25]: Creating SBS sample-by-component matrices. #&gt; ✓ [2020-06-22 14:31:25]: SBS-6 matrix created. #&gt; ✓ [2020-06-22 14:31:25]: SBS-96 matrix created. #&gt; ✓ [2020-06-22 14:31:25]: SBS-1536 matrix created. #&gt; ℹ [2020-06-22 14:31:25]: Return SBS-96 as major matrix. #&gt; ✓ [2020-06-22 14:31:25]: Done. #&gt; ℹ [2020-06-22 14:31:25]: 9.202 secs elapsed. mt_tally$nmf_matrix[1:5, 1:5] #&gt; A[T&gt;C]A C[T&gt;C]A G[T&gt;C]A T[T&gt;C]A A[C&gt;T]A #&gt; TCGA-AB-2802 0 0 0 0 0 #&gt; TCGA-AB-2803 0 0 0 0 2 #&gt; TCGA-AB-2804 0 0 0 0 2 #&gt; TCGA-AB-2805 0 0 0 0 0 #&gt; TCGA-AB-2806 0 0 0 0 0 We use notion left[ref&gt;mut]right to mark each component, e.g. C[T&gt;G]A means a base T with 5’ adjacent base C and 3’ adjacent base A is mutated to base G. 2.2.2 Other Situations Above we show the most common SBS classifications, there are other situations supported by sigminer, including other classifications for SBS records and other mutation types (DBS and ID). All situations about SBS, DBS and ID signatures are well documented in wiki of SigProfilerMatrixGenerator package. 2.2.2.1 Other SBS classifications After sig_tally() called, the most used matrix is store in nmf_matrix, and all matrices generated by sigminer are stored in all_matrices. str(mt_tally$all_matrices, max.level = 1) #&gt; List of 3 #&gt; $ SBS_6 : int [1:193, 1:6] 1 0 0 2 1 0 1 1 2 2 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_96 : int [1:193, 1:96] 0 0 0 0 0 0 1 0 1 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_1536: int [1:193, 1:1536] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 If you add the strand classification, all matrices can be generated by sigminer will return. mt_tally2 &lt;- sig_tally( laml, ref_genome = &quot;BSgenome.Hsapiens.UCSC.hg19&quot;, useSyn = TRUE, add_trans_bias = TRUE ) #&gt; ℹ [2020-06-22 14:31:26]: Started. #&gt; ✓ [2020-06-22 14:31:26]: Reference genome loaded. #&gt; ✓ [2020-06-22 14:31:26]: Variants from MAF object queried. #&gt; ✓ [2020-06-22 14:31:26]: Chromosome names checked. #&gt; ✓ [2020-06-22 14:31:26]: Sex chromosomes properly handled. #&gt; ✓ [2020-06-22 14:31:26]: Variant start and end position checked. #&gt; ✓ [2020-06-22 14:31:26]: Variant data for matrix generation preprocessed. #&gt; ℹ [2020-06-22 14:31:26]: SBS matrix generation - start. #&gt; ℹ [2020-06-22 14:31:26]: Extracting 5&#39; and 3&#39; adjacent bases. #&gt; ℹ [2020-06-22 14:31:26]: Extracting +/- 20bp around mutated bases for background C&gt;T estimation. #&gt; ℹ [2020-06-22 14:31:27]: Estimating APOBEC enrichment scores. #&gt; ℹ [2020-06-22 14:31:27]: Performing one-way Fisher&#39;s test for APOBEC enrichment. #&gt; ✓ [2020-06-22 14:31:27]: APOBEC related mutations are enriched in 3.297% of samples (APOBEC enrichment score &gt; 2; 6 of 182 samples) #&gt; ℹ [2020-06-22 14:31:27]: Creating SBS sample-by-component matrices. #&gt; ✓ [2020-06-22 14:31:27]: SBS-6 matrix created. #&gt; ✓ [2020-06-22 14:31:27]: SBS-96 matrix created. #&gt; ✓ [2020-06-22 14:31:27]: SBS-1536 matrix created. #&gt; ✓ [2020-06-22 14:31:27]: SBS-24 (6x4) matrix created. #&gt; ✓ [2020-06-22 14:31:27]: SBS-384 (96x4) matrix created. #&gt; ✓ [2020-06-22 14:31:27]: SBS-6144 (1536x4) matrix created. #&gt; ℹ [2020-06-22 14:31:27]: Return SBS-384 as major matrix. #&gt; ✓ [2020-06-22 14:31:27]: Done. #&gt; ℹ [2020-06-22 14:31:27]: 1.464 secs elapsed. str(mt_tally2$all_matrices, max.level = 1) #&gt; List of 6 #&gt; $ SBS_6 : int [1:193, 1:6] 1 0 0 2 1 0 1 1 2 2 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_24 : int [1:193, 1:24] 1 0 0 1 1 0 0 1 1 1 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_96 : int [1:193, 1:96] 0 0 0 0 0 0 1 0 1 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_384 : int [1:193, 1:384] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_1536: int [1:193, 1:1536] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_6144: int [1:193, 1:6144] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 2.2.2.2 DBS and ID components If you want to generate DBS or ID matrices, just modify the mode option. mt_tally_DBS &lt;- sig_tally( laml, ref_genome = &quot;BSgenome.Hsapiens.UCSC.hg19&quot;, useSyn = TRUE, mode = &quot;DBS&quot;, add_trans_bias = TRUE ) #&gt; ℹ [2020-06-22 14:31:27]: Started. #&gt; ✓ [2020-06-22 14:31:27]: Reference genome loaded. #&gt; ✓ [2020-06-22 14:31:27]: Variants from MAF object queried. #&gt; ✓ [2020-06-22 14:31:27]: Chromosome names checked. #&gt; ✓ [2020-06-22 14:31:27]: Sex chromosomes properly handled. #&gt; ✓ [2020-06-22 14:31:27]: Variant start and end position checked. #&gt; ✓ [2020-06-22 14:31:27]: Variant data for matrix generation preprocessed. #&gt; ℹ [2020-06-22 14:31:27]: DBS matrix generation - start. #&gt; ℹ [2020-06-22 14:31:28]: Searching DBS records... #&gt; ✓ [2020-06-22 14:31:29]: Done. #&gt; x [2020-06-22 14:31:29]: Zero DBSs to analyze! #&gt; Error in send_stop(&quot;Zero DBSs to analyze!&quot;): #&gt; ℹ [2020-06-22 14:31:29]: 1.789 secs elapsed. str(mt_tally_DBS$all_matrices, max.level = 1) #&gt; Error in str(mt_tally_DBS$all_matrices, max.level = 1): 找不到对象&#39;mt_tally_DBS&#39; Program will stop if no records to analyze. Let’s see ID records. mt_tally_ID &lt;- sig_tally( laml, ref_genome = &quot;BSgenome.Hsapiens.UCSC.hg19&quot;, useSyn = TRUE, mode = &quot;ID&quot;, add_trans_bias = TRUE ) #&gt; ℹ [2020-06-22 14:31:30]: Started. #&gt; ✓ [2020-06-22 14:31:30]: Reference genome loaded. #&gt; ✓ [2020-06-22 14:31:30]: Variants from MAF object queried. #&gt; ✓ [2020-06-22 14:31:30]: Chromosome names checked. #&gt; ✓ [2020-06-22 14:31:30]: Sex chromosomes properly handled. #&gt; ✓ [2020-06-22 14:31:30]: Variant start and end position checked. #&gt; ✓ [2020-06-22 14:31:30]: Variant data for matrix generation preprocessed. #&gt; ℹ [2020-06-22 14:31:30]: INDEL matrix generation - start. #&gt; ✓ [2020-06-22 14:31:31]: Reference sequences queried from genome. #&gt; ✓ [2020-06-22 14:31:31]: INDEL length extracted. #&gt; ✓ [2020-06-22 14:31:31]: Adjacent copies counted. #&gt; ✓ [2020-06-22 14:31:31]: Microhomology size calculated. #&gt; ✓ [2020-06-22 14:31:31]: INDEL records classified into different components (types). #&gt; ✓ [2020-06-22 14:31:31]: ID-28 matrix created. #&gt; ✓ [2020-06-22 14:31:31]: ID-83 matrix created. #&gt; ✓ [2020-06-22 14:31:31]: ID-415 matrix created. #&gt; ℹ [2020-06-22 14:31:31]: Return ID-415 as major matrix. #&gt; ✓ [2020-06-22 14:31:31]: Done. #&gt; ℹ [2020-06-22 14:31:31]: 1.139 secs elapsed. str(mt_tally_ID$all_matrices, max.level = 1) #&gt; List of 3 #&gt; $ ID_28 : int [1:193, 1:28] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ ID_83 : int [1:193, 1:83] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ ID_415:&#39;data.frame&#39;: 193 obs. of 415 variables: 2.2.2.3 Take togother If you want to get all matrices for SBS, DBS and ID at the same time, you don’t need to write a for loop or type three times to do this. Just set mode='ALL', sigminer will do it for you. mt_tally_all &lt;- sig_tally( laml, ref_genome = &quot;BSgenome.Hsapiens.UCSC.hg19&quot;, useSyn = TRUE, mode = &quot;ALL&quot;, add_trans_bias = TRUE ) #&gt; ℹ [2020-06-22 14:31:31]: Started. #&gt; ✓ [2020-06-22 14:31:31]: Reference genome loaded. #&gt; ✓ [2020-06-22 14:31:31]: Variants from MAF object queried. #&gt; ✓ [2020-06-22 14:31:31]: Chromosome names checked. #&gt; ✓ [2020-06-22 14:31:31]: Sex chromosomes properly handled. #&gt; ✓ [2020-06-22 14:31:31]: Variant start and end position checked. #&gt; ✓ [2020-06-22 14:31:31]: Variant data for matrix generation preprocessed. #&gt; ℹ [2020-06-22 14:31:31]: All types of matrices generation - start. #&gt; ℹ [2020-06-22 14:31:31]: SBS matrix generation - start. #&gt; ℹ [2020-06-22 14:31:31]: Extracting 5&#39; and 3&#39; adjacent bases. #&gt; ℹ [2020-06-22 14:31:32]: Extracting +/- 20bp around mutated bases for background C&gt;T estimation. #&gt; ℹ [2020-06-22 14:31:32]: Estimating APOBEC enrichment scores. #&gt; ℹ [2020-06-22 14:31:32]: Performing one-way Fisher&#39;s test for APOBEC enrichment. #&gt; ✓ [2020-06-22 14:31:32]: APOBEC related mutations are enriched in 3.297% of samples (APOBEC enrichment score &gt; 2; 6 of 182 samples) #&gt; ℹ [2020-06-22 14:31:32]: Creating SBS sample-by-component matrices. #&gt; ✓ [2020-06-22 14:31:32]: SBS-6 matrix created. #&gt; ✓ [2020-06-22 14:31:32]: SBS-96 matrix created. #&gt; ✓ [2020-06-22 14:31:32]: SBS-1536 matrix created. #&gt; ✓ [2020-06-22 14:31:32]: SBS-24 (6x4) matrix created. #&gt; ✓ [2020-06-22 14:31:32]: SBS-384 (96x4) matrix created. #&gt; ✓ [2020-06-22 14:31:32]: SBS-6144 (1536x4) matrix created. #&gt; ℹ [2020-06-22 14:31:32]: Return SBS-384 as major matrix. #&gt; ℹ [2020-06-22 14:31:32]: DBS matrix generation - start. #&gt; ℹ [2020-06-22 14:31:32]: Searching DBS records... #&gt; ✓ [2020-06-22 14:31:34]: Done. #&gt; x [2020-06-22 14:31:34]: Zero DBSs to analyze! #&gt; ℹ [2020-06-22 14:31:34]: INDEL matrix generation - start. #&gt; ✓ [2020-06-22 14:31:35]: Reference sequences queried from genome. #&gt; ✓ [2020-06-22 14:31:35]: INDEL length extracted. #&gt; ✓ [2020-06-22 14:31:35]: Adjacent copies counted. #&gt; ✓ [2020-06-22 14:31:35]: Microhomology size calculated. #&gt; ✓ [2020-06-22 14:31:35]: INDEL records classified into different components (types). #&gt; ✓ [2020-06-22 14:31:35]: ID-28 matrix created. #&gt; ✓ [2020-06-22 14:31:35]: ID-83 matrix created. #&gt; ✓ [2020-06-22 14:31:35]: ID-415 matrix created. #&gt; ℹ [2020-06-22 14:31:35]: Return ID-415 as major matrix. #&gt; ℹ [2020-06-22 14:31:35]: All types of matrices generation (APOBEC scores included) - end. #&gt; ✓ [2020-06-22 14:31:35]: Done. #&gt; ℹ [2020-06-22 14:31:35]: 3.724 secs elapsed. str(mt_tally_all, max.level = 1) #&gt; List of 10 #&gt; $ SBS_6 : int [1:193, 1:6] 1 0 0 2 1 0 1 1 2 2 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_24 : int [1:193, 1:24] 1 0 0 1 1 0 0 1 1 1 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_96 : int [1:193, 1:96] 0 0 0 0 0 0 1 0 1 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_384 : int [1:193, 1:384] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_1536 : int [1:193, 1:1536] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_6144 : int [1:193, 1:6144] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ ID_28 : int [1:193, 1:28] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ ID_83 : int [1:193, 1:83] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ ID_415 :&#39;data.frame&#39;: 193 obs. of 415 variables: #&gt; $ APOBEC_scores:Classes &#39;data.table&#39; and &#39;data.frame&#39;: 182 obs. of 44 variables: #&gt; ..- attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; #&gt; ..- attr(*, &quot;index&quot;)= int(0) #&gt; .. ..- attr(*, &quot;__APOBEC_Enriched&quot;)= int [1:182] 106 147 5 6 8 9 10 11 12 13 ... Please note, in this case, just a list containing matrices will return. 2.3 Extract Signatures There are two methods can be used to implement signature extraction. Firstly estimate signature number and then extract signatures. This method is powered by NMF package (Gaujoux and Seoighe 2010). Auto-extract signatures by automatic relevance determination technique in nonnegative matrix factorization (Tan and Févotte 2012), the code is implemented by SignatureAnalyzer (Kim et al. 2016) and exported to sigminer. 2.3.1 Method 1: Estimate Signature Number To estimate signature number, we firstly run NMF for multiple times and calculate some measures from the results, then select the best signature number based on the measure vs. signature number plot. This is done by sig_estimate() function. Let’s try signature number 2-5. For simplicity, we just run NMF twice for each signature number. We use 4 cores to speed up the computation. mt_est &lt;- sig_estimate(mt_tally$nmf_matrix, range = 2:5, nrun = 2, use_random = TRUE, cores = 4, pConstant = 1e-13, verbose = TRUE ) pConstant option is set to avoid errors raised by NMF package. We can show signature number survey for different measures by show_sig_number_survey2(). ## You can also select the measures to show ## by &#39;what&#39; option show_sig_number_survey2(mt_est$survey, mt_est$survey.random) For the details of all the measures above, please read Gaujoux and Seoighe (2010) and vignette of R package NMF. Typically, measure cophenetic is used for determing the signature number. We can easily generate an elbow plot with functionshow_sig_number_survey()`. show_sig_number_survey(mt_est$survey, right_y = NULL) Cophenetic indicates the robustness of consensus matrix clustering. In this situation, 2 or 3 is good. The most common approach is to use the cophenetic correlation coefficient. Brunet et al. suggested choosing the smallest value of r for which this coefficient starts decreasing. (Gaujoux and Seoighe 2010) However, there are no gold standard to determine the signature number. Sometimes, you should consider multiple measures. Remember, the most important thing is that you should have a good biological explanation for each signature. The best solution in study may not be the best solution in math. 2.3.2 Method 1: Extract Signatures After selecting a proper signature, you can now extract signatures. In general, use 30~50 NMF runs will get a robust result. mt_sig &lt;- sig_extract(mt_tally$nmf_matrix, n_sig = 3, nrun = 10, cores = 4, pConstant = 1e-13 ) 2.3.3 Method 2: Auto-extract If you have no idea to select a optimal signature number from technologies above, you can try auto-extract feature here. It uses a bayesian variant of NMF algorithm. You need to set a maximum signature number (default is 25) and run times to get the result. mt_sig2 &lt;- sig_auto_extract(mt_tally$nmf_matrix, K0 = 10, nrun = 10) At default, the code will use ‘robust’ strategy to return the result (see strategy option). It means that if you run 10 times and 6 of them return 4 signatures, then the optimal result with 4 signatures will be returned. The info of each run can be given as: mt_sig2$Raw$summary_run #&gt; # A tibble: 10 x 4 #&gt; Run K posterior file #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 8 2 1822. /var/folders/mx/rfkl27z90c96wbmn3_kjk8c80000gn/T//RtmpTrCKrZ/BayesNMF.8.rds #&gt; 2 6 2 1815. /var/folders/mx/rfkl27z90c96wbmn3_kjk8c80000gn/T//RtmpTrCKrZ/BayesNMF.6.rds #&gt; 3 9 3 1793. /var/folders/mx/rfkl27z90c96wbmn3_kjk8c80000gn/T//RtmpTrCKrZ/BayesNMF.9.rds #&gt; 4 2 2 1789. /var/folders/mx/rfkl27z90c96wbmn3_kjk8c80000gn/T//RtmpTrCKrZ/BayesNMF.2.rds #&gt; 5 5 2 1785. /var/folders/mx/rfkl27z90c96wbmn3_kjk8c80000gn/T//RtmpTrCKrZ/BayesNMF.5.rds #&gt; 6 3 3 1766. /var/folders/mx/rfkl27z90c96wbmn3_kjk8c80000gn/T//RtmpTrCKrZ/BayesNMF.3.rds #&gt; 7 10 2 1764. /var/folders/mx/rfkl27z90c96wbmn3_kjk8c80000gn/T//RtmpTrCKrZ/BayesNMF.10.rds #&gt; 8 1 4 1740. /var/folders/mx/rfkl27z90c96wbmn3_kjk8c80000gn/T//RtmpTrCKrZ/BayesNMF.1.rds #&gt; 9 4 3 1718. /var/folders/mx/rfkl27z90c96wbmn3_kjk8c80000gn/T//RtmpTrCKrZ/BayesNMF.4.rds #&gt; 10 7 3 1706. /var/folders/mx/rfkl27z90c96wbmn3_kjk8c80000gn/T//RtmpTrCKrZ/BayesNMF.7.rds 2.4 Match Signatures After extracting signatures, we need to know their etiologies. This can be done by comparing the identified signatures and reference signatures from COSMIC database. sim &lt;- get_sig_similarity(mt_sig) #&gt; -Comparing against COSMIC signatures #&gt; ------------------------------------ #&gt; --Found Sig1 most similar to COSMIC_1 #&gt; Aetiology: spontaneous deamination of 5-methylcytosine [similarity: 0.871] #&gt; --Found Sig2 most similar to COSMIC_1 #&gt; Aetiology: spontaneous deamination of 5-methylcytosine [similarity: 0.841] #&gt; --Found Sig3 most similar to COSMIC_1 #&gt; Aetiology: spontaneous deamination of 5-methylcytosine [similarity: 0.776] #&gt; ------------------------------------ #&gt; Return result invisiblely. The result object sim is a list. str(sim) #&gt; List of 3 #&gt; $ similarity : num [1:3, 1:30] 0.871 0.841 0.776 0.221 0.049 0.211 0.277 0.345 0.286 0.217 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; .. ..$ : chr [1:3] &quot;Sig1&quot; &quot;Sig2&quot; &quot;Sig3&quot; #&gt; .. ..$ : chr [1:30] &quot;COSMIC_1&quot; &quot;COSMIC_2&quot; &quot;COSMIC_3&quot; &quot;COSMIC_4&quot; ... #&gt; $ aetiology_db:List of 1 #&gt; ..$ : chr [1:30] &quot;spontaneous deamination of 5-methylcytosine&quot; &quot;APOBEC Cytidine Deaminase (C&gt;T)&quot; &quot;defects in DNA-DSB repair by HR&quot; &quot;exposure to tobacco (smoking) mutagens&quot; ... #&gt; $ best_match :List of 3 #&gt; ..$ Sig1:List of 2 #&gt; .. ..$ aetiology : chr &quot;spontaneous deamination of 5-methylcytosine&quot; #&gt; .. ..$ best_match: chr &quot;Best match: COSMIC_1 [similarity: 0.871]&quot; #&gt; ..$ Sig2:List of 2 #&gt; .. ..$ aetiology : chr &quot;spontaneous deamination of 5-methylcytosine&quot; #&gt; .. ..$ best_match: chr &quot;Best match: COSMIC_1 [similarity: 0.841]&quot; #&gt; ..$ Sig3:List of 2 #&gt; .. ..$ aetiology : chr &quot;spontaneous deamination of 5-methylcytosine&quot; #&gt; .. ..$ best_match: chr &quot;Best match: COSMIC_1 [similarity: 0.776]&quot; #&gt; - attr(*, &quot;class&quot;)= chr [1:2] &quot;similarity&quot; &quot;list&quot; From the result we can see that only one signature is clear. If you find unknow signatures in your study, you should explore the etiologies by other analyses and even experiments. The similarity matrix can be plotted. pheatmap::pheatmap(sim$similarity) You can also try the COSMIC signature database V3 with: sim_v3 &lt;- get_sig_similarity(mt_sig, sig_db = &quot;SBS&quot;) #&gt; -Comparing against COSMIC signatures #&gt; ------------------------------------ #&gt; --Found Sig1 most similar to SBS1 #&gt; Aetiology: spontaneous or enzymatic deamination of 5-methylcytosine [similarity: 0.844] #&gt; --Found Sig2 most similar to SBS1 #&gt; Aetiology: spontaneous or enzymatic deamination of 5-methylcytosine [similarity: 0.782] #&gt; --Found Sig3 most similar to SBS6 #&gt; Aetiology: defective DNA mismatch repair [similarity: 0.694] #&gt; ------------------------------------ #&gt; Return result invisiblely. 2.5 Operate Signature The result of sig_extract() or sig_auto_extract() is a list with Signature class. You can use $ or use operation function to obtain the data stored in it. To get the signature matrix: # Or mt_sig$Signature sig_signature(mt_sig)[1:5, ] #&gt; Sig1 Sig2 Sig3 #&gt; A[T&gt;C]A 4.347168e-02 2.419528e-14 5.443553e-19 #&gt; C[T&gt;C]A 5.587475e-19 1.208329e-14 1.030792e-02 #&gt; G[T&gt;C]A 4.699434e-14 3.233990e-03 5.602686e-03 #&gt; T[T&gt;C]A 3.498551e-15 4.448091e-15 2.945119e-03 #&gt; A[C&gt;T]A 2.003145e-14 7.513116e-02 1.388966e-14 To get signature exposure matrix: # Or mt_sig$Exposure sig_exposure(mt_sig)[, 1:5] #&gt; TCGA-AB-2802 TCGA-AB-2803 TCGA-AB-2804 TCGA-AB-2805 TCGA-AB-2806 #&gt; Sig1 5.967386 4.220468 6.470106e-12 7.828328e+00 4.979286 #&gt; Sig2 1.490521 7.651933 7.000000e+00 6.171672e+00 5.190129 #&gt; Sig3 2.542092 2.127600 2.134479e-12 4.303842e-13 4.830585 get_sig_exposure() may be more useful, it can be used to return a data.frame and set an exposure threshold. get_sig_exposure(mt_sig) #&gt; sample Sig1 Sig2 Sig3 #&gt; 1: TCGA-AB-2802 5.967386e+00 1.490521e+00 2.542092e+00 #&gt; 2: TCGA-AB-2803 4.220468e+00 7.651933e+00 2.127600e+00 #&gt; 3: TCGA-AB-2804 6.470106e-12 7.000000e+00 2.134479e-12 #&gt; 4: TCGA-AB-2805 7.828328e+00 6.171672e+00 4.303842e-13 #&gt; 5: TCGA-AB-2806 4.979286e+00 5.190129e+00 4.830585e+00 #&gt; --- #&gt; 189: TCGA-AB-3007 7.000000e+00 2.234347e-12 6.506815e-12 #&gt; 190: TCGA-AB-3008 4.000000e+00 1.393582e-11 1.371823e-11 #&gt; 191: TCGA-AB-3009 9.664115e+00 9.658138e+00 1.667775e+01 #&gt; 192: TCGA-AB-3011 6.000000e+00 4.721216e-12 2.653254e-12 #&gt; 193: TCGA-AB-3012 4.657863e+00 1.242847e-11 2.342137e+00 For plotting signature profile and exposure profile, please go to chapter 7. For optimizing signature exposure, please use sig_fit(). References "],
["cnsig.html", "Chapter 3 Copy Number Signature Identification 3.1 Introduction 3.2 Read Data 3.3 Tally Components 3.4 Extract Signatures", " Chapter 3 Copy Number Signature Identification 3.1 Introduction Unlike several mutation types presented in current COSMIC database for generating mutational signatures, it is hard to represent copy number features and generate the matrix for NMF decomposition. Macintyre et al. (2018) created a new method to generate the matrix for extracting signature by non-negative matrix factorization (NMF) algorithm. The steps are: derive 6 copy number features from absolute copy number profile apply mixture modelling to breakdown each feature distribution into mixtures of Gaussian or mixtures of Poisson distributions generate a sample-by-component matrix representing the sum of posterior probabilities of each copy-number event being assigned to each component. Based on previous work, our group devised a new method which discards the statistical modeling and create a fixed number of predefined components from 8 copy number features to generate the matrix as the input of NMF (Wang et al. 2020), it is easier to reproduce the result, apply to different cancer types and compare results. To test if the method would works, we applied it to prostate cancer and successfully identified 5 copy number signatures. Currently, there are few studies focus on copy number signatures and no reference signature database for matching and explaining the etiologies. If you study them, you should do extra work to explore and validate them. Furthermore, the input absolute copy number data may be generated by different methods and platforms, it is normal that the contribution of some copy number feature components varies a little and result in relatively lower signature similarity when comparing different cohorts or different copy number profile generation methods. 3.2 Read Data The input requires absolute copy number profile with following information: Segment chromosome. Segment start. Segment end. Absolute copy number value for this segment: must be integer (i.e. total copy number value in results from Sequenza or FACETS). Sample ID. The input data can be result from any softwares which provides information above. For chip data/segmentation data (copy ratio is available), ABSOLUTE is recommended. For raw sequencing data, Sequenza and FACETS are recommended. The import work is done by read_copynumber(), this function supports data.frame or file, and even result directory from ABSOLUTE. # Load toy dataset of absolute copynumber profile load(system.file(&quot;extdata&quot;, &quot;toy_segTab.RData&quot;, package = &quot;sigminer&quot;, mustWork = TRUE )) cn &lt;- read_copynumber(segTabs, seg_cols = c(&quot;chromosome&quot;, &quot;start&quot;, &quot;end&quot;, &quot;segVal&quot;), genome_build = &quot;hg19&quot;, complement = FALSE, verbose = TRUE ) #&gt; ℹ [2020-06-22 14:31:40]: Started. #&gt; ℹ [2020-06-22 14:31:40]: Genome build : hg19. #&gt; ℹ [2020-06-22 14:31:40]: Genome measure: called. #&gt; ✓ [2020-06-22 14:31:40]: Chromosome size database for build obtained. #&gt; ℹ [2020-06-22 14:31:40]: Reading input. #&gt; ✓ [2020-06-22 14:31:40]: A data frame as input detected. #&gt; ✓ [2020-06-22 14:31:40]: Column names checked. #&gt; ✓ [2020-06-22 14:31:40]: Column order set. #&gt; ✓ [2020-06-22 14:31:40]: Chromosomes unified. #&gt; ✓ [2020-06-22 14:31:40]: Data imported. #&gt; ℹ [2020-06-22 14:31:40]: Segments info: #&gt; ℹ [2020-06-22 14:31:40]: Keep - 467 #&gt; ℹ [2020-06-22 14:31:40]: Drop - 0 #&gt; ✓ [2020-06-22 14:31:40]: Adjacent segments with same copy number value joined #&gt; ✓ [2020-06-22 14:31:41]: Segmental table cleaned. #&gt; ℹ [2020-06-22 14:31:41]: Annotating. #&gt; #&gt; ✓ [2020-06-22 14:31:41]: Annotation done. #&gt; ℹ [2020-06-22 14:31:41]: Summarizing per sample. #&gt; ✓ [2020-06-22 14:31:41]: Summarized. #&gt; ℹ [2020-06-22 14:31:41]: Generating CopyNumber object. #&gt; ✓ [2020-06-22 14:31:41]: Generated. #&gt; ℹ [2020-06-22 14:31:41]: Validating object. #&gt; ✓ [2020-06-22 14:31:41]: Done. #&gt; ℹ [2020-06-22 14:31:41]: 1.223 secs elapsed. cn #&gt; An object of class CopyNumber #&gt; ============================= #&gt; sample n_of_seg n_of_cnv n_of_amp n_of_del n_of_vchr cna_burden #&gt; 1: TCGA-DF-A2KN-01A-11D-A17U-01 33 6 5 1 4 0.000 #&gt; 2: TCGA-19-2621-01B-01D-0911-01 33 8 5 3 5 0.099 #&gt; 3: TCGA-B6-A0X5-01A-21D-A107-01 28 8 4 4 2 0.087 #&gt; 4: TCGA-A8-A07S-01A-11D-A036-01 38 11 2 9 4 0.112 #&gt; 5: TCGA-26-6174-01A-21D-1842-01 43 13 8 5 8 0.119 #&gt; 6: TCGA-CV-7432-01A-11D-2128-01 40 16 7 9 9 0.198 #&gt; 7: TCGA-06-0644-01A-02D-0310-01 46 19 5 14 8 0.165 #&gt; 8: TCGA-A5-A0G2-01A-11D-A042-01 39 21 5 16 10 0.393 #&gt; 9: TCGA-99-7458-01A-11D-2035-01 48 26 10 16 13 0.318 #&gt; 10: TCGA-05-4417-01A-22D-1854-01 52 37 33 4 17 0.654 Currently, you can refer to extract_facets_cnv() and extract_seqz_cnv() in https://github.com/ShixiangWang/prad_signature/blob/master/analysis/src/99-functions.R to see how to get tidy data from a result directory of FACETS or Sequenza. 3.3 Tally Components Currently, there are two methods for generating sample-by-component matrix, i.e. “W” or “M”. Options sigminer.sex and sigminer.copynumber.max are used to control the processing of sex and max values. Run ?sig_tally to see more. options(sigminer.sex = &quot;male&quot;, sigminer.copynumber.max = 10) # Load copy number object load(system.file(&quot;extdata&quot;, &quot;toy_copynumber.RData&quot;, package = &quot;sigminer&quot;, mustWork = TRUE )) # Use method designed by Wang, Shixiang et al. cn_tally_W &lt;- sig_tally(cn, method = &quot;W&quot;) # Use method designed by Macintyre et al. cn_tally_M &lt;- sig_tally(cn, method = &quot;M&quot;) This step return a list containing information about copy number features, components and matrix for NMF etc. 3.4 Extract Signatures When you get the matrix, you can just do the signature extractin as SBS signatures (see chapter Chapter 2). So here we won’t talk much. cn_tally_W$nmf_matrix[1:5, 1:5] #&gt; BP10MB[0] BP10MB[1] BP10MB[2] BP10MB[3] BP10MB[4] #&gt; TCGA-05-4417-01A-22D-1854-01 275 20 5 0 0 #&gt; TCGA-06-0644-01A-02D-0310-01 289 5 4 0 1 #&gt; TCGA-19-2621-01B-01D-0911-01 294 2 3 1 0 #&gt; TCGA-26-6174-01A-21D-1842-01 288 4 7 1 0 #&gt; TCGA-99-7458-01A-11D-2035-01 284 9 5 1 1 # library(NMF) sig_w &lt;- sig_extract(cn_tally_W$nmf_matrix, n_sig = 2, pConstant = 1e-13) References "],
["sigfit.html", "Chapter 4 Signature Fit: Sample Signature Exposure Quantification and Analysis 4.1 Fit Signatures from reference databases 4.2 Fit Custom Signatures 4.3 Performance Comparison 4.4 Estimate Exposure Stability by Bootstrap", " Chapter 4 Signature Fit: Sample Signature Exposure Quantification and Analysis Besides de novo signature discovery shown in previous chapters, another common task is that you have gotten a reference signature database (either from known database like COSMIC or de novo discovery step), you want to know how these signatures fit in a new sample. That’s the target of sig_fit(). sig_fit() uses multiple methods to compute exposure of pre-defined signatures from the total alteration spectrum of a (can be more) sample. Use ?sig_fit see more detail. To show how this function works, we use a sample with maximum mutation counts as example data. i &lt;- which.max(apply(mt_tally$nmf_matrix, 1, sum)) example_mat &lt;- mt_tally$nmf_matrix[i, , drop = FALSE] %&gt;% t() head(example_mat) #&gt; TCGA-AB-3009 #&gt; A[T&gt;C]A 0 #&gt; C[T&gt;C]A 0 #&gt; G[T&gt;C]A 0 #&gt; T[T&gt;C]A 0 #&gt; A[C&gt;T]A 0 #&gt; C[C&gt;T]A 0 4.1 Fit Signatures from reference databases For SBS signatures, users may want to directly use reference signatures from COSMIC database. This can be done by specifying the option sig_index. sig_fit(example_mat, sig_index = 1:30) #&gt; ℹ [2020-06-22 14:31:43]: Started. #&gt; ✓ [2020-06-22 14:31:43]: Signature index detected. #&gt; ℹ [2020-06-22 14:31:43]: Checking signature database in package. #&gt; ℹ [2020-06-22 14:31:43]: Checking signature index. #&gt; ℹ [2020-06-22 14:31:43]: Valid index for db &#39;legacy&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #&gt; ✓ [2020-06-22 14:31:43]: Database and index checked. #&gt; ✓ [2020-06-22 14:31:43]: Signature normalized. #&gt; ℹ [2020-06-22 14:31:43]: Checking row number for catalog matrix and signature matrix. #&gt; ✓ [2020-06-22 14:31:43]: Checked. #&gt; ℹ [2020-06-22 14:31:43]: Checking rownames for catalog matrix and signature matrix. #&gt; ℹ [2020-06-22 14:31:43]: Matrix V and W don&#39;t have same orders. Try reordering... #&gt; ✓ [2020-06-22 14:31:43]: Checked. #&gt; ✓ [2020-06-22 14:31:43]: Method &#39;QP&#39; detected. #&gt; ✓ [2020-06-22 14:31:43]: Corresponding function generated. #&gt; ℹ [2020-06-22 14:31:43]: Calling function. #&gt; ✓ [2020-06-22 14:31:43]: Done. #&gt; ℹ [2020-06-22 14:31:43]: Generating output signature exposures. #&gt; ✓ [2020-06-22 14:31:43]: Done. #&gt; ℹ [2020-06-22 14:31:43]: 0.05 secs elapsed. #&gt; TCGA-AB-3009 #&gt; COSMIC_1 20.634 #&gt; COSMIC_2 0.000 #&gt; COSMIC_3 0.000 #&gt; COSMIC_4 0.000 #&gt; COSMIC_5 0.000 #&gt; COSMIC_6 4.186 #&gt; COSMIC_7 0.000 #&gt; COSMIC_8 0.000 #&gt; COSMIC_9 0.000 #&gt; COSMIC_10 3.048 #&gt; COSMIC_11 0.000 #&gt; COSMIC_12 0.000 #&gt; COSMIC_13 0.000 #&gt; COSMIC_14 0.000 #&gt; COSMIC_15 8.131 #&gt; COSMIC_16 0.000 #&gt; COSMIC_17 0.000 #&gt; COSMIC_18 0.000 #&gt; COSMIC_19 0.000 #&gt; COSMIC_20 0.000 #&gt; COSMIC_21 0.000 #&gt; COSMIC_22 0.000 #&gt; COSMIC_23 0.000 #&gt; COSMIC_24 0.000 #&gt; COSMIC_25 0.000 #&gt; COSMIC_26 0.000 #&gt; COSMIC_27 0.000 #&gt; COSMIC_28 0.000 #&gt; COSMIC_29 0.000 #&gt; COSMIC_30 0.000 That’s it! You can set type = &quot;relative&quot; for getting relative exposure. sig_fit(example_mat, sig_index = 1:30, type = &quot;relative&quot;) #&gt; ℹ [2020-06-22 14:31:43]: Started. #&gt; ✓ [2020-06-22 14:31:43]: Signature index detected. #&gt; ℹ [2020-06-22 14:31:43]: Checking signature database in package. #&gt; ℹ [2020-06-22 14:31:43]: Checking signature index. #&gt; ℹ [2020-06-22 14:31:43]: Valid index for db &#39;legacy&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #&gt; ✓ [2020-06-22 14:31:43]: Database and index checked. #&gt; ✓ [2020-06-22 14:31:43]: Signature normalized. #&gt; ℹ [2020-06-22 14:31:43]: Checking row number for catalog matrix and signature matrix. #&gt; ✓ [2020-06-22 14:31:43]: Checked. #&gt; ℹ [2020-06-22 14:31:43]: Checking rownames for catalog matrix and signature matrix. #&gt; ℹ [2020-06-22 14:31:43]: Matrix V and W don&#39;t have same orders. Try reordering... #&gt; ✓ [2020-06-22 14:31:43]: Checked. #&gt; ✓ [2020-06-22 14:31:43]: Method &#39;QP&#39; detected. #&gt; ✓ [2020-06-22 14:31:43]: Corresponding function generated. #&gt; ℹ [2020-06-22 14:31:43]: Calling function. #&gt; ✓ [2020-06-22 14:31:43]: Done. #&gt; ℹ [2020-06-22 14:31:43]: Generating output signature exposures. #&gt; ✓ [2020-06-22 14:31:43]: Done. #&gt; ℹ [2020-06-22 14:31:43]: 0.038 secs elapsed. #&gt; TCGA-AB-3009 #&gt; COSMIC_1 0.573 #&gt; COSMIC_2 0.000 #&gt; COSMIC_3 0.000 #&gt; COSMIC_4 0.000 #&gt; COSMIC_5 0.000 #&gt; COSMIC_6 0.116 #&gt; COSMIC_7 0.000 #&gt; COSMIC_8 0.000 #&gt; COSMIC_9 0.000 #&gt; COSMIC_10 0.085 #&gt; COSMIC_11 0.000 #&gt; COSMIC_12 0.000 #&gt; COSMIC_13 0.000 #&gt; COSMIC_14 0.000 #&gt; COSMIC_15 0.226 #&gt; COSMIC_16 0.000 #&gt; COSMIC_17 0.000 #&gt; COSMIC_18 0.000 #&gt; COSMIC_19 0.000 #&gt; COSMIC_20 0.000 #&gt; COSMIC_21 0.000 #&gt; COSMIC_22 0.000 #&gt; COSMIC_23 0.000 #&gt; COSMIC_24 0.000 #&gt; COSMIC_25 0.000 #&gt; COSMIC_26 0.000 #&gt; COSMIC_27 0.000 #&gt; COSMIC_28 0.000 #&gt; COSMIC_29 0.000 #&gt; COSMIC_30 0.000 For multiple samples, you can return a data.table, it can be easier to integrate with other information in R. sig_fit(t(mt_tally$nmf_matrix[1:5, ]), sig_index = 1:30, return_class = &quot;data.table&quot;, rel_threshold = 0.05) #&gt; ℹ [2020-06-22 14:31:44]: Started. #&gt; ✓ [2020-06-22 14:31:44]: Signature index detected. #&gt; ℹ [2020-06-22 14:31:44]: Checking signature database in package. #&gt; ℹ [2020-06-22 14:31:44]: Checking signature index. #&gt; ℹ [2020-06-22 14:31:44]: Valid index for db &#39;legacy&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #&gt; ✓ [2020-06-22 14:31:44]: Database and index checked. #&gt; ✓ [2020-06-22 14:31:44]: Signature normalized. #&gt; ℹ [2020-06-22 14:31:44]: Checking row number for catalog matrix and signature matrix. #&gt; ✓ [2020-06-22 14:31:44]: Checked. #&gt; ℹ [2020-06-22 14:31:44]: Checking rownames for catalog matrix and signature matrix. #&gt; ℹ [2020-06-22 14:31:44]: Matrix V and W don&#39;t have same orders. Try reordering... #&gt; ✓ [2020-06-22 14:31:44]: Checked. #&gt; ✓ [2020-06-22 14:31:44]: Method &#39;QP&#39; detected. #&gt; ✓ [2020-06-22 14:31:44]: Corresponding function generated. #&gt; ℹ [2020-06-22 14:31:44]: Calling function. #&gt; ✓ [2020-06-22 14:31:44]: Done. #&gt; ℹ [2020-06-22 14:31:44]: Generating output signature exposures. #&gt; ✓ [2020-06-22 14:31:44]: Done. #&gt; ℹ [2020-06-22 14:31:44]: 0.055 secs elapsed. #&gt; sample COSMIC_1 COSMIC_2 COSMIC_3 COSMIC_4 COSMIC_5 COSMIC_6 COSMIC_7 COSMIC_8 COSMIC_9 COSMIC_10 COSMIC_11 COSMIC_12 COSMIC_13 #&gt; 1: TCGA-AB-2802 3.129 0.895 0 0.000 0 1.088 0 0 0 0 0 0 0 #&gt; 2: TCGA-AB-2803 10.003 0.000 0 1.717 0 0.000 0 0 0 0 0 0 0 #&gt; 3: TCGA-AB-2804 7.000 0.000 0 0.000 0 0.000 0 0 0 0 0 0 0 #&gt; 4: TCGA-AB-2805 13.628 0.000 0 0.000 0 0.000 0 0 0 0 0 0 0 #&gt; 5: TCGA-AB-2806 10.825 0.000 0 0.000 0 0.000 0 0 0 0 0 0 0 #&gt; COSMIC_14 COSMIC_15 COSMIC_16 COSMIC_17 COSMIC_18 COSMIC_19 COSMIC_20 COSMIC_21 COSMIC_22 COSMIC_23 COSMIC_24 COSMIC_25 COSMIC_26 COSMIC_27 #&gt; 1: 0 0.000 0 0 0.000 2.833 0 0 2.056 0 0 0 0 0 #&gt; 2: 0 0.000 0 0 0.000 2.280 0 0 0.000 0 0 0 0 0 #&gt; 3: 0 0.000 0 0 0.000 0.000 0 0 0.000 0 0 0 0 0 #&gt; 4: 0 0.000 0 0 0.000 0.000 0 0 0.000 0 0 0 0 0 #&gt; 5: 0 1.799 0 0 2.376 0.000 0 0 0.000 0 0 0 0 0 #&gt; COSMIC_28 COSMIC_29 COSMIC_30 #&gt; 1: 0 0 0 #&gt; 2: 0 0 0 #&gt; 3: 0 0 0 #&gt; 4: 0 0 0 #&gt; 5: 0 0 0 When you set multiple signatures, we recommend setting rel_threshold option, which will set exposure of a signature to 0 if its relative exposure in a sample less than the rel_threshold. 4.2 Fit Custom Signatures We have already determined the SBS signatures before. Here we can set them to sig option. sig_fit(example_mat, sig = mt_sig) #&gt; ℹ [2020-06-22 14:31:44]: Started. #&gt; ✓ [2020-06-22 14:31:44]: Signature object detected. #&gt; ✓ [2020-06-22 14:31:44]: Database and index checked. #&gt; ✓ [2020-06-22 14:31:44]: Signature normalized. #&gt; ℹ [2020-06-22 14:31:44]: Checking row number for catalog matrix and signature matrix. #&gt; ✓ [2020-06-22 14:31:44]: Checked. #&gt; ℹ [2020-06-22 14:31:44]: Checking rownames for catalog matrix and signature matrix. #&gt; ✓ [2020-06-22 14:31:44]: Checked. #&gt; ✓ [2020-06-22 14:31:44]: Method &#39;QP&#39; detected. #&gt; ✓ [2020-06-22 14:31:44]: Corresponding function generated. #&gt; ℹ [2020-06-22 14:31:44]: Calling function. #&gt; ✓ [2020-06-22 14:31:44]: Done. #&gt; ℹ [2020-06-22 14:31:44]: Generating output signature exposures. #&gt; ✓ [2020-06-22 14:31:44]: Done. #&gt; ℹ [2020-06-22 14:31:44]: 0.031 secs elapsed. #&gt; TCGA-AB-3009 #&gt; Sig1 6.614 #&gt; Sig2 5.734 #&gt; Sig3 23.653 4.3 Performance Comparison Now that we can use sig_fit for getting optimal exposures, we can compare the RSS between raw matrix and the reconstructed matrix either by NMF and sig_fit(). i.e. \\[ RSS = \\sum(\\hat H - H)^2 \\] ## Exposure got from NMF sum((apply(mt_sig$Signature, 2, function(x) x / sum(x)) %*% mt_sig$Exposure - t(mt_tally$nmf_matrix))^2) #&gt; [1] 1868.616 ## Exposure optimized by sig_fit H_estimate &lt;- apply(mt_sig$Signature, 2, function(x) x / sum(x)) %*% sig_fit(t(mt_tally$nmf_matrix), sig = mt_sig) #&gt; ℹ [2020-06-22 14:31:45]: Started. #&gt; ✓ [2020-06-22 14:31:45]: Signature object detected. #&gt; ✓ [2020-06-22 14:31:45]: Database and index checked. #&gt; ✓ [2020-06-22 14:31:45]: Signature normalized. #&gt; ℹ [2020-06-22 14:31:45]: Checking row number for catalog matrix and signature matrix. #&gt; ✓ [2020-06-22 14:31:45]: Checked. #&gt; ℹ [2020-06-22 14:31:45]: Checking rownames for catalog matrix and signature matrix. #&gt; ✓ [2020-06-22 14:31:45]: Checked. #&gt; ✓ [2020-06-22 14:31:45]: Method &#39;QP&#39; detected. #&gt; ✓ [2020-06-22 14:31:45]: Corresponding function generated. #&gt; ℹ [2020-06-22 14:31:45]: Calling function. #&gt; ✓ [2020-06-22 14:31:45]: Done. #&gt; ℹ [2020-06-22 14:31:45]: Generating output signature exposures. #&gt; ✓ [2020-06-22 14:31:45]: Done. #&gt; ℹ [2020-06-22 14:31:45]: 0.044 secs elapsed. H_estimate &lt;- apply(H_estimate, 2, function(x) ifelse(is.nan(x), 0, x)) H_real &lt;- t(mt_tally$nmf_matrix) sum((H_estimate - H_real)^2) #&gt; [1] 1772.987 4.4 Estimate Exposure Stability by Bootstrap This feature is based on sig_fit(), it uses the resampling data of original input and runs sig_fit() multiple times to estimate the exposure. Bootstrap replicates &gt;= 100 is recommended, here I just use 10 times for illustration. bt_result &lt;- sig_fit_bootstrap(example_mat, sig = mt_sig, n = 10) #&gt; ℹ [2020-06-22 14:31:45]: Started. #&gt; ℹ [2020-06-22 14:31:45]: Checking catalog. #&gt; ✓ [2020-06-22 14:31:45]: Done. #&gt; ℹ [2020-06-22 14:31:45]: About to start bootstrap. #&gt; → Bootstrapping 10 times. → Total 10 times, starting no.1. → Total 10 times, starting no.2. → Total 10 times, starting no.3. → Total 10 times, starting no.4. → Total 10 times, starting no.5. → Total 10 times, starting no.6. → Total 10 times, starting no.7. → Total 10 times, starting no.8. → Total 10 times, starting no.9. → Total 10 times, starting no.10. ✓ [2020-06-22 14:31:46]: Bootstrap done. #&gt; ✓ [2020-06-22 14:31:46]: Signature exposures collected. #&gt; ✓ [2020-06-22 14:31:46]: Errors collected. #&gt; ✓ [2020-06-22 14:31:46]: Done. #&gt; ℹ [2020-06-22 14:31:46]: 0.579 secs elapsed. bt_result #&gt; $expo #&gt; Rep_1 Rep_2 Rep_3 Rep_4 Rep_5 Rep_6 Rep_7 Rep_8 Rep_9 Rep_10 #&gt; Sig1 8.666 9.407 10.286 18.351 7.115 5.543 0.000 15.117 16.824 15.443 #&gt; Sig2 11.622 1.429 1.370 2.475 0.813 2.620 3.436 5.724 8.039 7.793 #&gt; Sig3 15.711 25.164 24.344 15.175 28.071 27.837 32.564 15.159 11.138 12.764 #&gt; #&gt; $errors #&gt; Rep_1 Rep_2 Rep_3 Rep_4 Rep_5 Rep_6 Rep_7 Rep_8 Rep_9 Rep_10 #&gt; 7.433 7.250 7.250 7.546 7.298 7.275 7.477 7.477 7.735 7.611 Currently, I haven’t create plot method for the result, but you can plot it very easily with boxplot(). boxplot(t(bt_result$expo)) "],
["subtyping.html", "Chapter 5 Subtype Prediction", " Chapter 5 Subtype Prediction To expand the power of signatures to clinical application, based on signature discovery and signature fitting workflow, we can go further build neutral network model prediction model with keras. This feature is currently experimental and implemented in sigminer’s child package sigminer.prediction. "],
["cnobject.html", "Chapter 6 CopyNumber Object 6.1 Profile 6.2 Distribution", " Chapter 6 CopyNumber Object 6.1 Profile show_cn_profile(cn, nrow = 2, ncol = 1) show_cn_circos(cn, samples = 1) 6.2 Distribution show_cn_distribution(cn, mode = &quot;ld&quot;) show_cn_distribution(cn, mode = &quot;cd&quot;) "],
["sigobject.html", "Chapter 7 Signature Object 7.1 Signature Profile 7.2 Exposure Profile 7.3 Consensus Map 7.4 Catalogue Profile", " Chapter 7 Signature Object Signature is a core object in sigminer, it stores signatures and their exposures. Here we show how to plot signature profile and exposure profile. The result plots are basically ggplot based, so they can be further edited by your custom operations with ggplot grammar. 7.1 Signature Profile A signature is composed of distinct component patterns. They can be shown by show_sig_profile(). Of note, for different types of signature, the bar heights may have different meanings. SBS signatures are displayed based on the observed component frequency of the human genome, i.e., representing the relative proportions of mutations generated by each signature based on the actual trinucleotide frequencies of the reference human genome. Similar to SBS signatures, copy number signatures are displayed based on the observed component frequency of the human genome. Of note, considering the count process of each feature is relatively independent, the profile is row normalized by each feature, unlike Macintyre et al. (2018) did column normalization (this method is easy to mislead readers), so the bar height can be compared within/between features. 7.1.1 SBS Signature profile show_sig_profile(mt_sig, mode = &quot;SBS&quot;, paint_axis_text = FALSE, x_label_angle = 90) show_sig_profile(mt_sig, mode = &quot;SBS&quot;, style = &quot;cosmic&quot;, x_label_angle = 90) 7.1.2 Copy Number Signature Porfile For copy number signatures from tally method “W”, you have to specify the normalize option as “feature”, so the bar heights can be more clearly compared. show_sig_profile(sig_w, mode = &quot;copynumber&quot;, normalize = &quot;feature&quot;, method = &quot;W&quot;, style = &quot;cosmic&quot; ) 7.1.3 COSMIC Signature Profile Users can show profile of COSMIC signatures by show_cosmic_sig_profile(). To see valid signature numbers, run show_cosmic_sig_profile(sig_db = &quot;legacy&quot;) #&gt; #&gt; Valid index for db &#39;legacy&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ‘legacy’ is for COSMIC v2. show_cosmic_sig_profile(sig_db = &quot;SBS&quot;) #&gt; #&gt; Valid index for db &#39;SBS&#39;: #&gt; 1 2 3 4 5 6 7a 7b 7c 7d 8 9 10a 10b 11 12 13 14 15 16 17a 17b 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 84 85 To show the plot, specify signature shortnames to sig_index option. show_cosmic_sig_profile(sig_index = c(1, 5, 6), style = &quot;cosmic&quot;) #&gt; #&gt; Valid index for db &#39;legacy&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 show_cosmic_sig_profile(sig_index = c(1, 2, 3), style = &quot;cosmic&quot;, sig_db = &quot;DBS&quot;) #&gt; #&gt; Valid index for db &#39;DBS&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 show_cosmic_sig_profile(sig_index = c(4, 5, 6), style = &quot;cosmic&quot;, sig_db = &quot;ID&quot;) #&gt; #&gt; Valid index for db &#39;ID&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 7.2 Exposure Profile show_sig_exposure(mt_sig) show_sig_exposure(mt_sig, style = &quot;cosmic&quot;) show_sig_exposure(sig_w, style = &quot;cosmic&quot;) Of note: For COSMIC signatures, the absolute exposure is the estimated mutation counts. For copy number signatures, the absolute exposure is the estimated copy number segments. 7.3 Consensus Map This can only support the result from sig_extract() with multiple runs. show_sig_consensusmap(mt_sig) 7.4 Catalogue Profile Based on plot method for signature, we can plot raw catalogue profile. show_catalogue(t(mt_tally$nmf_matrix), style = &quot;cosmic&quot;, x_label_angle = 90) At default, the function sums all samples. Users can specify sample ID. show_catalogue(t(mt_tally$nmf_matrix), style = &quot;cosmic&quot;, samples = &quot;TCGA-AB-3009&quot;, x_label_angle = 90) "],
["association-analysis.html", "Chapter 8 Association Analysis and Visualization", " Chapter 8 Association Analysis and Visualization "],
["group-analysis.html", "Chapter 9 Group Analysis and Visualization 9.1 Group Generation 9.2 Group Comparison Analysis 9.3 Group Visualization", " Chapter 9 Group Analysis and Visualization Group analysis is a common task in cancer study. sigminer supports dividing samples into multiple groups and comparing genotype/phenotype feature measures. 9.1 Group Generation There are multiple methods to generate groups, including ‘consensus’ (default, can be only used by result from sig_extract()), ‘k-means’ etc. After determining groups, sigminer will assign each group to a signature with maximum fraction. We may say a group is Sig_x enriched. mt_grps &lt;- get_groups(mt_sig, method = &quot;consensus&quot;, match_consensus = TRUE) #&gt; ℹ [2020-06-22 14:32:13]: Started. #&gt; ✓ [2020-06-22 14:32:13]: &#39;Signature&#39; object detected. #&gt; ℹ [2020-06-22 14:32:13]: Obtaining clusters from the hierarchical clustering of the consensus matrix... #&gt; ℹ [2020-06-22 14:32:13]: Finding the dominant signature of each group... #&gt; =&gt; Generating a table of group and dominant signature: #&gt; #&gt; Sig1 Sig2 Sig3 #&gt; 1 48 35 1 #&gt; 2 13 11 30 #&gt; 3 6 14 35 #&gt; =&gt; Assigning a group to a signature with the maxium fraction (stored in &#39;map_table&#39; attr)... #&gt; ℹ [2020-06-22 14:32:13]: Summarizing... #&gt; group #1: 84 samples with Sig1 enriched. #&gt; group #2: 54 samples with Sig3 enriched. #&gt; group #3: 55 samples with Sig3 enriched. #&gt; ! [2020-06-22 14:32:13]: The &#39;enrich_sig&#39; column is set to dominant signature in one group, please check and make it consistent with biological meaning (correct it by hand if necessary). #&gt; ℹ [2020-06-22 14:32:13]: 0.134 secs elapsed. head(mt_grps) #&gt; sample group silhouette_width enrich_sig #&gt; 1: TCGA-AB-2922 1 0.1680 Sig1 #&gt; 2: TCGA-AB-2816 1 0.1780 Sig1 #&gt; 3: TCGA-AB-2972 1 0.2610 Sig1 #&gt; 4: TCGA-AB-2854 1 0.0659 Sig1 #&gt; 5: TCGA-AB-2847 1 0.0644 Sig1 #&gt; 6: TCGA-AB-2843 1 0.0609 Sig1 The returned sample orders match sample orders in clustered consensus matrix. show_sig_consensusmap(mt_sig) Sometimes, the mapping between groups and enriched signatures may not right. Users should check it and even correct it manually. attr(mt_grps, &quot;map_table&quot;) #&gt; #&gt; Sig1 Sig2 Sig3 #&gt; 1 48 35 1 #&gt; 2 13 11 30 #&gt; 3 6 14 35 9.2 Group Comparison Analysis 9.3 Group Visualization "],
["datasets.html", "Chapter 10 Datasets 10.1 Reference Annotation 10.2 Copy Number components setting", " Chapter 10 Datasets 10.1 Reference Annotation sigminer stores many reference annotation datasets for internal calculation. It can be exported for other usage either by data() or get_genome_annotation(). Currently, there are the following datasets: centromeres.hg19 centromeres.hg38 chromsize.hg19 chromsize.hg38 cytobands.hg19 cytobands.hg38 An example is given as below: data(&quot;centromeres.hg19&quot;) head(centromeres.hg19) #&gt; chrom left.base right.base #&gt; 1 chr1 121535434 124535434 #&gt; 2 chr2 92326171 95326171 #&gt; 3 chr3 90504854 93504854 #&gt; 4 chr4 49660117 52660117 #&gt; 5 chr5 46405641 49405641 #&gt; 6 chr6 58830166 61830166 get_genome_annotation() can better control the returned data.frame. get_genome_annotation( data_type = &quot;chr_size&quot;, chrs = c(&quot;chr1&quot;, &quot;chr10&quot;, &quot;chr20&quot;), genome_build = &quot;hg19&quot; ) #&gt; chrom size #&gt; 1 chr1 249250621 #&gt; 2 chr10 135534747 #&gt; 3 chr20 63025520 More see ?get_genome_annotation. 10.2 Copy Number components setting Dataset CN.features is a predefined component data table for identifying copy number signatures by method “Wang”. Users can define a custom table with similar structure and pass it to function like sig_tally(). Detail about how to generate this dataset can be viewed at https://github.com/ShixiangWang/sigminer/blob/master/data-raw/CN-features.R. CN.features #&gt; feature component label min max #&gt; 1: BP10MB BP10MB[0] point 0 0 #&gt; 2: BP10MB BP10MB[1] point 1 1 #&gt; 3: BP10MB BP10MB[2] point 2 2 #&gt; 4: BP10MB BP10MB[3] point 3 3 #&gt; 5: BP10MB BP10MB[4] point 4 4 #&gt; 6: BP10MB BP10MB[5] point 5 5 #&gt; 7: BP10MB BP10MB[&gt;5] range 5 Inf #&gt; 8: BPArm BPArm[0] point 0 0 #&gt; 9: BPArm BPArm[1] point 1 1 #&gt; 10: BPArm BPArm[2] point 2 2 #&gt; 11: BPArm BPArm[3] point 3 3 #&gt; 12: BPArm BPArm[4] point 4 4 #&gt; 13: BPArm BPArm[5] point 5 5 #&gt; 14: BPArm BPArm[6] point 6 6 #&gt; 15: BPArm BPArm[7] point 7 7 #&gt; 16: BPArm BPArm[8] point 8 8 #&gt; 17: BPArm BPArm[9] point 9 9 #&gt; 18: BPArm BPArm[10] point 10 10 #&gt; 19: BPArm BPArm[&gt;10 &amp; &lt;=20] range 10 20 #&gt; 20: BPArm BPArm[&gt;20 &amp; &lt;=30] range 20 30 #&gt; 21: BPArm BPArm[&gt;30] range 30 Inf #&gt; 22: CN CN[0] point 0 0 #&gt; 23: CN CN[1] point 1 1 #&gt; 24: CN CN[2] point 2 2 #&gt; 25: CN CN[3] point 3 3 #&gt; 26: CN CN[4] point 4 4 #&gt; 27: CN CN[&gt;4 &amp; &lt;=8] range 4 8 #&gt; 28: CN CN[&gt;8] range 8 Inf #&gt; 29: CNCP CNCP[0] point 0 0 #&gt; 30: CNCP CNCP[1] point 1 1 #&gt; 31: CNCP CNCP[2] point 2 2 #&gt; 32: CNCP CNCP[3] point 3 3 #&gt; 33: CNCP CNCP[4] point 4 4 #&gt; 34: CNCP CNCP[&gt;4 &amp; &lt;=8] range 4 8 #&gt; 35: CNCP CNCP[&gt;8] range 8 Inf #&gt; 36: OsCN OsCN[0] point 0 0 #&gt; 37: OsCN OsCN[1] point 1 1 #&gt; 38: OsCN OsCN[2] point 2 2 #&gt; 39: OsCN OsCN[3] point 3 3 #&gt; 40: OsCN OsCN[4] point 4 4 #&gt; 41: OsCN OsCN[&gt;4 &amp; &lt;=10] range 4 10 #&gt; 42: OsCN OsCN[&gt;10] range 10 Inf #&gt; 43: SS SS[&lt;=2] range -Inf 2 #&gt; 44: SS SS[&gt;2 &amp; &lt;=3] range 2 3 #&gt; 45: SS SS[&gt;3 &amp; &lt;=4] range 3 4 #&gt; 46: SS SS[&gt;4 &amp; &lt;=5] range 4 5 #&gt; 47: SS SS[&gt;5 &amp; &lt;=6] range 5 6 #&gt; 48: SS SS[&gt;6 &amp; &lt;=7] range 6 7 #&gt; 49: SS SS[&gt;7 &amp; &lt;=8] range 7 8 #&gt; 50: SS SS[&gt;8] range 8 Inf #&gt; 51: NC50 NC50[&lt;=2] range -Inf 2 #&gt; 52: NC50 NC50[3] point 3 3 #&gt; 53: NC50 NC50[4] point 4 4 #&gt; 54: NC50 NC50[5] point 5 5 #&gt; 55: NC50 NC50[6] point 6 6 #&gt; 56: NC50 NC50[7] point 7 7 #&gt; 57: NC50 NC50[&gt;7] range 7 Inf #&gt; 58: BoChr BoChr[1] point 1 1 #&gt; 59: BoChr BoChr[2] point 2 2 #&gt; 60: BoChr BoChr[3] point 3 3 #&gt; 61: BoChr BoChr[4] point 4 4 #&gt; 62: BoChr BoChr[5] point 5 5 #&gt; 63: BoChr BoChr[6] point 6 6 #&gt; 64: BoChr BoChr[7] point 7 7 #&gt; 65: BoChr BoChr[8] point 8 8 #&gt; 66: BoChr BoChr[9] point 9 9 #&gt; 67: BoChr BoChr[10] point 10 10 #&gt; 68: BoChr BoChr[11] point 11 11 #&gt; 69: BoChr BoChr[12] point 12 12 #&gt; 70: BoChr BoChr[13] point 13 13 #&gt; 71: BoChr BoChr[14] point 14 14 #&gt; 72: BoChr BoChr[15] point 15 15 #&gt; 73: BoChr BoChr[16] point 16 16 #&gt; 74: BoChr BoChr[17] point 17 17 #&gt; 75: BoChr BoChr[18] point 18 18 #&gt; 76: BoChr BoChr[19] point 19 19 #&gt; 77: BoChr BoChr[20] point 20 20 #&gt; 78: BoChr BoChr[21] point 21 21 #&gt; 79: BoChr BoChr[22] point 22 22 #&gt; 80: BoChr BoChr[23] point 23 23 #&gt; feature component label min max "],
["convert.html", "Chapter 11 SBS Signature Conversion", " Chapter 11 SBS Signature Conversion Converts signatures between two representations relative to different sets of mutational opportunities. Currently, only SBS signature is supported. # Load SBS signature load(system.file(&quot;extdata&quot;, &quot;toy_mutational_signature.RData&quot;, package = &quot;sigminer&quot;, mustWork = TRUE )) # Exome-relative to Genome-relative sig_converted &lt;- sig_convert(sig2, from = &quot;human-exome&quot;, to = &quot;human-genome&quot; ) sig_converted #&gt; Sig1 Sig2 Sig3 #&gt; A[C&gt;A]A 0.000000e+00 1.283652e-02 2.354578e-204 #&gt; A[C&gt;A]C 0.000000e+00 1.866572e-02 0.000000e+00 #&gt; A[C&gt;A]G 0.000000e+00 1.618700e-03 0.000000e+00 #&gt; A[C&gt;A]T 0.000000e+00 7.572233e-03 0.000000e+00 #&gt; C[C&gt;A]A 0.000000e+00 1.209076e-02 0.000000e+00 #&gt; C[C&gt;A]C 0.000000e+00 7.032249e-03 1.170400e-133 #&gt; C[C&gt;A]G 0.000000e+00 3.839313e-03 1.165310e-269 #&gt; C[C&gt;A]T 0.000000e+00 1.166974e-02 0.000000e+00 #&gt; G[C&gt;A]A 0.000000e+00 1.025669e-02 4.089543e-15 #&gt; G[C&gt;A]C 2.975389e-296 4.002311e-03 0.000000e+00 #&gt; G[C&gt;A]G 4.796114e-02 4.527374e-117 0.000000e+00 #&gt; G[C&gt;A]T 0.000000e+00 5.994876e-03 1.669814e-131 #&gt; T[C&gt;A]A 0.000000e+00 3.324941e-96 7.673114e-02 #&gt; T[C&gt;A]C 0.000000e+00 1.467589e-02 9.720402e-229 #&gt; T[C&gt;A]G 0.000000e+00 3.199454e-03 0.000000e+00 #&gt; T[C&gt;A]T 0.000000e+00 2.338506e-02 0.000000e+00 #&gt; A[C&gt;G]A 0.000000e+00 1.198076e-02 1.210238e-153 #&gt; A[C&gt;G]C 0.000000e+00 3.999796e-03 0.000000e+00 #&gt; A[C&gt;G]G 9.976549e-02 7.184837e-58 0.000000e+00 #&gt; A[C&gt;G]T 0.000000e+00 7.572233e-03 9.731662e-108 #&gt; C[C&gt;G]A 0.000000e+00 8.732217e-03 1.472610e-34 #&gt; C[C&gt;G]C 0.000000e+00 1.875266e-03 0.000000e+00 #&gt; C[C&gt;G]G 0.000000e+00 4.429976e-03 1.144811e-70 #&gt; C[C&gt;G]T 1.398527e-01 1.003533e-19 0.000000e+00 #&gt; G[C&gt;G]A 1.227107e-293 7.521572e-03 2.969058e-285 #&gt; G[C&gt;G]C 0.000000e+00 3.001734e-03 2.665595e-168 #&gt; G[C&gt;G]G 0.000000e+00 2.178881e-03 0.000000e+00 #&gt; G[C&gt;G]T 0.000000e+00 3.996584e-03 0.000000e+00 #&gt; T[C&gt;G]A 0.000000e+00 4.493267e-03 2.338585e-311 #&gt; T[C&gt;G]C 0.000000e+00 5.336688e-03 1.100445e-248 #&gt; T[C&gt;G]G 0.000000e+00 5.027714e-03 2.505791e-283 #&gt; T[C&gt;G]T 0.000000e+00 8.094828e-03 4.211703e-12 #&gt; A[C&gt;T]A 0.000000e+00 4.278842e-02 6.186711e-285 #&gt; A[C&gt;T]C 0.000000e+00 3.266500e-02 4.009287e-180 #&gt; A[C&gt;T]G 0.000000e+00 8.943317e-02 1.936180e-271 #&gt; A[C&gt;T]T 0.000000e+00 2.366323e-02 0.000000e+00 #&gt; C[C&gt;T]A 0.000000e+00 2.552494e-02 0.000000e+00 #&gt; C[C&gt;T]C 0.000000e+00 1.406450e-02 1.334078e-226 #&gt; C[C&gt;T]G 0.000000e+00 5.463637e-02 9.737288e-158 #&gt; C[C&gt;T]T 0.000000e+00 3.695418e-02 4.246509e-172 #&gt; G[C&gt;T]A 0.000000e+00 1.550033e-134 1.379990e-01 #&gt; G[C&gt;T]C 0.000000e+00 2.401387e-02 9.655208e-197 #&gt; G[C&gt;T]G 0.000000e+00 5.665090e-02 1.322415e-193 #&gt; G[C&gt;T]T 0.000000e+00 3.197267e-02 1.483309e-124 #&gt; T[C&gt;T]A 0.000000e+00 3.504749e-02 1.602583e-125 #&gt; T[C&gt;T]C 0.000000e+00 2.868470e-02 2.192251e-133 #&gt; T[C&gt;T]G 0.000000e+00 5.607061e-45 3.725237e-01 #&gt; T[C&gt;T]T 0.000000e+00 2.248563e-02 5.991874e-150 #&gt; A[T&gt;A]A 0.000000e+00 8.169022e-163 4.909543e-207 #&gt; A[T&gt;A]C 0.000000e+00 9.451235e-03 9.169290e-161 #&gt; A[T&gt;A]G 0.000000e+00 1.860257e-209 3.781700e-02 #&gt; A[T&gt;A]T 0.000000e+00 3.646724e-03 0.000000e+00 #&gt; C[T&gt;A]A 0.000000e+00 9.626354e-63 1.877035e-152 #&gt; C[T&gt;A]C 0.000000e+00 4.098575e-03 8.954807e-03 #&gt; C[T&gt;A]G 0.000000e+00 7.584736e-03 1.779246e-46 #&gt; C[T&gt;A]T 0.000000e+00 4.886651e-03 0.000000e+00 #&gt; G[T&gt;A]A 0.000000e+00 1.923466e-257 1.645056e-02 #&gt; G[T&gt;A]C 0.000000e+00 5.990275e-03 2.816093e-138 #&gt; G[T&gt;A]G 0.000000e+00 2.491146e-03 5.966918e-137 #&gt; G[T&gt;A]T 1.780073e-01 1.470587e-107 0.000000e+00 #&gt; T[T&gt;A]A 0.000000e+00 0.000000e+00 1.576605e-78 #&gt; T[T&gt;A]C 0.000000e+00 3.652510e-193 3.025830e-02 #&gt; T[T&gt;A]G 0.000000e+00 0.000000e+00 3.102984e-02 #&gt; T[T&gt;A]T 0.000000e+00 5.570191e-03 2.661350e-186 #&gt; A[T&gt;C]A 0.000000e+00 3.673499e-02 2.037390e-236 #&gt; A[T&gt;C]C 0.000000e+00 4.875997e-80 8.069896e-02 #&gt; A[T&gt;C]G 0.000000e+00 2.533400e-02 4.653276e-300 #&gt; A[T&gt;C]T 0.000000e+00 3.403610e-02 1.137147e-235 #&gt; C[T&gt;C]A 0.000000e+00 7.619558e-03 1.273356e-94 #&gt; C[T&gt;C]C 0.000000e+00 1.116095e-02 1.501723e-122 #&gt; C[T&gt;C]G 0.000000e+00 9.506418e-50 9.321794e-02 #&gt; C[T&gt;C]T 0.000000e+00 1.172796e-02 1.679251e-87 #&gt; G[T&gt;C]A 0.000000e+00 4.585040e-03 5.536247e-03 #&gt; G[T&gt;C]C 0.000000e+00 5.073564e-255 4.133148e-02 #&gt; G[T&gt;C]G 0.000000e+00 6.850650e-03 0.000000e+00 #&gt; G[T&gt;C]T 3.036787e-50 1.058999e-02 7.624782e-161 #&gt; T[T&gt;C]A 0.000000e+00 1.774320e-183 1.917769e-02 #&gt; T[T&gt;C]C 3.471970e-224 7.796288e-03 0.000000e+00 #&gt; T[T&gt;C]G 0.000000e+00 9.993850e-03 0.000000e+00 #&gt; T[T&gt;C]T 0.000000e+00 2.116673e-02 4.729625e-249 #&gt; A[T&gt;G]A 0.000000e+00 6.559820e-03 0.000000e+00 #&gt; A[T&gt;G]C 0.000000e+00 8.576821e-159 1.467254e-02 #&gt; A[T&gt;G]G 0.000000e+00 1.544237e-03 3.140069e-03 #&gt; A[T&gt;G]T 0.000000e+00 3.646724e-03 0.000000e+00 #&gt; C[T&gt;G]A 0.000000e+00 1.088508e-03 0.000000e+00 #&gt; C[T&gt;G]C 0.000000e+00 5.252213e-03 5.352907e-111 #&gt; C[T&gt;G]G 0.000000e+00 6.320613e-03 0.000000e+00 #&gt; C[T&gt;G]T 1.505897e-01 2.544085e-94 2.345935e-218 #&gt; G[T&gt;G]A 9.796461e-02 2.199487e-93 1.446688e-154 #&gt; G[T&gt;G]C 0.000000e+00 1.996758e-03 0.000000e+00 #&gt; G[T&gt;G]G 0.000000e+00 3.736718e-03 0.000000e+00 #&gt; G[T&gt;G]T 0.000000e+00 3.701349e-72 1.494581e-02 #&gt; T[T&gt;G]A 1.142049e-01 5.198170e-158 0.000000e+00 #&gt; T[T&gt;G]C 0.000000e+00 4.872680e-03 0.000000e+00 #&gt; T[T&gt;G]G 0.000000e+00 1.798724e-19 1.551492e-02 #&gt; T[T&gt;G]T 1.716541e-01 1.775134e-54 0.000000e+00 show_sig_profile(sig2, style = &quot;cosmic&quot;) show_sig_profile(sig_converted, style = &quot;cosmic&quot;) "],
["references.html", "References", " References "]
]
