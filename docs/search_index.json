[
["index.html", "sigminer: Genomic Alteration Signature Analysis in R Introduction Installation Issues or Suggestions Preparation Citation and LICENSE", " sigminer: Genomic Alteration Signature Analysis in R Shixiang Wang, ShanghaiTech University Xue-Song Liu, ShanghaiTech University last revised on 2020-03-20 Introduction Genomic alterations including single nucleotide substitution (SBS), copy number alteration (CNA), etc. are the major force for cancer initialization and development. Due to the specificity of molecular lesions caused by genomic alterations, we can generate characteristic alteration spectra, called ‘signature’. To illustrate the biological significance of genome alteration signatures, we show some well organized figures here. Figure 0.1: The illustration of SBS signature, fig source: https://www.nature.com/articles/nrg3729 Figure 0.2: The illustration of SBS signature (2), fig source: https://www.nature.com/articles/s41467-018-05228-y SBS signature is previously known as mutational signature. SBS signatures are well studied and related to single-strand changes, typically caused by defective DNA repair. Common etiologies contain aging, defective DNA mismatch repair, smoking, ultraviolet light exposure and APOBOE. Currently, all SBS signatures are summarized in COSMIC database, including two versions: v2 and v3. Recently, Alexandrov et al. (2020) extends the concept of mutational signature to three types of mutation: SBS, DBS and INDEL. Here, we use genomic alteration signature to refer any kind of mutation type can be used to generate signature. Figure 0.3: The illustration of copy number signatures, fig source: https://www.nature.com/articles/s41588-018-0212-y Copy number signatures are less studied and many works are still to be done. To study signatures, we created an easy-to-use and scalable toolkit for genomic alteration signature analysis and visualization in R. We named it sigminer (signature + miner). This tool can help users to extract, analyze and visualize signatures from genomic alteration records, thus providing new insight into cancer study. Currently, sigminer supports two types of signature: SBS signature in the form of 96 components Copy number signature by the method either from Macintyre et al. (2018) or from our group work. Installation The sigminer package can be installed from CRAN or Github: remotes::install_github(&quot;ShixiangWang/sigminer&quot;) Issues or Suggestions Any issue can be posted on GitHub issue, we will reply ASAP. We have plans to extend other mutational signatures (like INDEL and DBS) to sigminer or extend reading input from other softwares, contribution is welcome. Preparation To reproduce the examples shown in this manual, users should load the following packages firstly. sigminer is requred to have version &gt;= 1.0.0. library(sigminer) library(NMF) Current manual uses sigminer 1.0.0. More info about sigminer can be given as: hello() #&gt; Thanks for using &#39;sigminer&#39; package! #&gt; ========================================================================= #&gt; Version: 1.0.0 #&gt; #&gt; Project home : https://github.com/ShixiangWang/sigminer #&gt; Bug report : https://github.com/ShixiangWang/sigminer/issues #&gt; Documentation: https://shixiangwang.github.io/sigminer-doc/ #&gt; ========================================================================= #&gt; Citation and LICENSE If you use sigminer in academic field, please cite our work: Copy number signature analyses in prostate cancer reveal distinct etiologies and clinical outcomes, under submission The software is made available for non commercial research purposes only under the MIT. However, notwithstanding any provision of the MIT License, the software currently may not be used for commercial purposes without explicit written permission after contacting Shixiang Wang wangshx@shanghaitech.edu.cn or Xue-Song Liu liuxs@shanghaitech.edu.cn. MIT © 2019-2020 Shixiang Wang, Xue-Song Liu MIT © 2018 Geoffrey Macintyre MIT © 2018 Anand Mayakonda Cancer Biology Group @ShanghaiTech Research group led by Xue-Song Liu in ShanghaiTech University References "],
["part-signature-identification.html", "(PART) Signature Identification", " (PART) Signature Identification "],
["sbssig.html", "Chapter 1 SBS Signature Identification Read Data Tally Components Extract Signatures Match Signatures Operate Signature", " Chapter 1 SBS Signature Identification In this chapter, we will introduce how to identify SBS signatures from SBS records of variant calling data. The signature identification procedure has been divided into 3 steps: Read mutation data Tally components: classify SBS into 96 components and generate sample matrix Extract signatures: estimate signature number and identify signatures Read Data The input data should be in MAF format, it can be either a MAF file or a data.frame. There is a famous R/Bioconductor package Maftools (Mayakonda et al. 2018) for analyzing MAF data. Here, we use the example MAF file stored in Maftools as input and extract SBS signatures from the data. Make sure library(sigminer) before running the following code. laml.maf &lt;- system.file(&quot;extdata&quot;, &quot;tcga_laml.maf.gz&quot;, package = &quot;maftools&quot;, mustWork = TRUE) laml &lt;- read_maf(maf = laml.maf) #&gt; -Reading #&gt; -Validating #&gt; -Silent variants: 475 #&gt; -Summarizing #&gt; -Processing clinical data #&gt; --Missing clinical data #&gt; -Finished in 0.340s elapsed (0.270s cpu) laml #&gt; An object of class MAF #&gt; ID summary Mean Median #&gt; 1: NCBI_Build 37 NA NA #&gt; 2: Center genome.wustl.edu NA NA #&gt; 3: Samples 193 NA NA #&gt; 4: nGenes 1241 NA NA #&gt; 5: Frame_Shift_Del 52 0.271 0 #&gt; 6: Frame_Shift_Ins 91 0.474 0 #&gt; 7: In_Frame_Del 10 0.052 0 #&gt; 8: In_Frame_Ins 42 0.219 0 #&gt; 9: Missense_Mutation 1342 6.990 7 #&gt; 10: Nonsense_Mutation 103 0.536 0 #&gt; 11: Splice_Site 92 0.479 0 #&gt; 12: total 1732 9.021 9 The laml is a MAF object. The MAF class is exported from Maftools to sigminer. So laml can be directly use functions provided by Maftools. As a MAF object, the mutation records are stored in slot data and maf.silent. head(laml@data) #&gt; Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome Start_Position End_Position Strand #&gt; 1: ABCA10 10349 genome.wustl.edu 37 17 67170917 67170917 + #&gt; 2: ABCA4 24 genome.wustl.edu 37 1 94490594 94490594 + #&gt; 3: ABCB11 8647 genome.wustl.edu 37 2 169780250 169780250 + #&gt; 4: ABCC3 8714 genome.wustl.edu 37 17 48760974 48760974 + #&gt; 5: ABCF1 23 genome.wustl.edu 37 6 30554429 30554429 + #&gt; 6: ABCG4 64137 genome.wustl.edu 37 11 119031351 119031351 + #&gt; Variant_Classification Variant_Type Reference_Allele Tumor_Seq_Allele1 Tumor_Seq_Allele2 Tumor_Sample_Barcode #&gt; 1: Splice_Site SNP T T C TCGA-AB-2988 #&gt; 2: Missense_Mutation SNP C C T TCGA-AB-2869 #&gt; 3: Missense_Mutation SNP G G A TCGA-AB-3009 #&gt; 4: Missense_Mutation SNP C C T TCGA-AB-2887 #&gt; 5: Missense_Mutation SNP G G A TCGA-AB-2920 #&gt; 6: Missense_Mutation SNP A A G TCGA-AB-2934 #&gt; Protein_Change i_TumorVAF_WU i_transcript_name #&gt; 1: p.K960R 45.66000 NM_080282.3 #&gt; 2: p.R1517H 38.12000 NM_000350.2 #&gt; 3: p.A1283V 46.97218 NM_003742.2 #&gt; 4: p.P1271S 56.41000 NM_003786.1 #&gt; 5: p.G658S 40.95000 NM_001025091.1 #&gt; 6: p.Y567C 32.84000 NM_022169.1 head(laml@maf.silent) #&gt; Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome Start_Position End_Position Strand #&gt; 1: ABCC11 85320 genome.wustl.edu 37 16 48244997 48244997 + #&gt; 2: ACAN 176 genome.wustl.edu 37 15 89401084 89401084 + #&gt; 3: ACAT1 38 genome.wustl.edu 37 11 108009744 108009744 + #&gt; 4: ACCN2 41 genome.wustl.edu 37 12 50452780 50452780 + #&gt; 5: ACTA2 59 genome.wustl.edu 37 10 90695109 90695109 + #&gt; 6: ACTL9 284382 genome.wustl.edu 37 19 8808551 8808551 + #&gt; Variant_Classification Variant_Type Reference_Allele Tumor_Seq_Allele1 Tumor_Seq_Allele2 Tumor_Sample_Barcode #&gt; 1: Silent SNP G G A TCGA-AB-2830 #&gt; 2: Silent SNP C C T TCGA-AB-2898 #&gt; 3: Silent SNP T T G TCGA-AB-2887 #&gt; 4: Silent SNP C C G TCGA-AB-3009 #&gt; 5: Silent SNP C C T TCGA-AB-2973 #&gt; 6: Silent SNP G G A TCGA-AB-2936 #&gt; Protein_Change i_TumorVAF_WU i_transcript_name #&gt; 1: p.I490I 34.2700000 NM_032583.3 #&gt; 2: p.S1756S 38.3000000 NM_013227.2 #&gt; 3: p.T185T 49.0400000 NM_000019.3 #&gt; 4: p.L77L 48.1000000 NM_020039.2 #&gt; 5: p.P335P 0.2012072 NM_001613.1 #&gt; 6: p.F167F 46.1500000 NM_178525.3 The data slot contains non-silent variants, and the maf.silent slot contains silent variants. Default uses Variant Classifications with High/Moderate variant consequences as non-silent variants. http://asia.ensembl.org/Help/Glossary?id=535: “Frame_Shift_Del”, “Frame_Shift_Ins”, “Splice_Site”, “Translation_Start_Site”,“Nonsense_Mutation”, “Nonstop_Mutation”, “In_Frame_Del”,“In_Frame_Ins”, “Missense_Mutation” (see ?read_maf). If you want to change, please set vc_nonSyn option. Other slots in MAF object are summary data either by sample or gene/variant type etc. slotNames(laml) #&gt; [1] &quot;data&quot; &quot;variants.per.sample&quot; &quot;variant.type.summary&quot; #&gt; [4] &quot;variant.classification.summary&quot; &quot;gene.summary&quot; &quot;summary&quot; #&gt; [7] &quot;maf.silent&quot; &quot;clinical.data&quot; Tally Components According to 3-nucleotide context (mutated base, 5’ and 3’ adjacent bases) and base complementary pairing principle, we can divide all SBS mutations into 96 mutation types. We call each mutation type as a component here. This classification is based the six substitution subtypes: C&gt;A, C&gt;G, C&gt;T, T&gt;A, T&gt;C, and T&gt;G (all substitutions are referred to by the pyrimidine of the mutated Watson—Crick base pair). Further, each of the substitutions is examined by incorporating information on the bases immediately 5’ and 3’ to each mutated base generating 96 possible mutation types (6 types of substitution x 4 types of 5’ base x 4 types of 3’ base). We tally components in each sample, and generate a sample-by-component matrix. if (require(&quot;BSgenome.Hsapiens.UCSC.hg19&quot;)) { mt_tally &lt;- sig_tally( laml, ref_genome = &quot;BSgenome.Hsapiens.UCSC.hg19&quot;, prefix = &quot;chr&quot;, add = TRUE, useSyn = TRUE ) } else { message(&quot;Please install package &#39;BSgenome.Hsapiens.UCSC.hg19&#39; firstly!&quot;) } #&gt; Warning in maftools::trinucleotideMatrix(object, ref_genome = ref_genome, : Chromosome names in MAF must match chromosome names in reference genome. #&gt; Ignorinig 101 single nucleotide variants from missing chromosomes chr23 #&gt; -Extracting 5&#39; and 3&#39; adjacent bases #&gt; -Extracting +/- 20bp around mutated bases for background C&gt;T estimation #&gt; -Estimating APOBEC enrichment scores #&gt; --Performing one-way Fisher&#39;s test for APOBEC enrichment #&gt; ---APOBEC related mutations are enriched in 3.315 % of samples (APOBEC enrichment score &gt; 2 ; 6 of 181 samples) #&gt; -Creating mutation matrix #&gt; --matrix of dimension 188x96 mt_tally$nmf_matrix[1:5, 1:5] #&gt; A[C&gt;A]A A[C&gt;A]C A[C&gt;A]G A[C&gt;A]T C[C&gt;A]A #&gt; TCGA-AB-2802 0 0 0 0 0 #&gt; TCGA-AB-2803 0 2 0 0 0 #&gt; TCGA-AB-2804 0 0 0 0 0 #&gt; TCGA-AB-2805 0 0 0 0 0 #&gt; TCGA-AB-2806 0 0 0 0 0 We use notion left[ref&gt;mut]right to mark each component, e.g. C[T&gt;G]A means a base T with 5’ adjacent base C and 3’ adjacent base A is mutated to base G. If you have used signature extraction feature in Maftools, you may feel familiar. Currently, Maftools is the backend for read_maf() and sig_tally for SBS mutation. Extract Signatures There are two methods can be used to implement signature extraction. Firstly estimate signature number and then extract signatures. This method is powered by NMF package (Gaujoux and Seoighe 2010). Auto-extract signatures by automatic relevance determination technique in nonnegative matrix factorization (Tan and Févotte 2012), the code is implemented by SignatureAnalyzer (Kim et al. 2016) and exported to sigminer. Method 1: Estimate Signature Number To estimate signature number, we firstly run NMF for multiple times and calculate some measures from the results, then select the best signature number based on the measure vs. signature number plot. This is done by sig_estimate() function. Let’s try signature number 2-5. For simplicity, we just run NMF twice for each signature number. We use 4 cores to speed up the computation. mt_est &lt;- sig_estimate(mt_tally$nmf_matrix, range = 2:5, nrun = 2, use_random = TRUE, cores = 4, pConstant = 1e-13, verbose = TRUE ) pConstant option is set to avoid errors raised by NMF package. We can show signature number survey for different measures by show_sig_number_survey2(). ## You can also select the measures to show ## by &#39;what&#39; option show_sig_number_survey2(mt_est$survey, mt_est$survey.random) For the details of all the measures above, please read Gaujoux and Seoighe (2010) and vignette of R package NMF. Typically, measure cophenetic is used for determing the signature number. We can easily generate an elbow plot with functionshow_sig_number_survey()`. show_sig_number_survey(mt_est$survey, right_y = NULL) Cophenetic indicates the robustness of consensus matrix clustering. In this situation, 2 or 3 is good. The most common approach is to use the cophenetic correlation coefficient. Brunet et al. suggested choosing the smallest value of r for which this coefficient starts decreasing. (Gaujoux and Seoighe 2010) However, there are no gold standard to determine the signature number. Sometimes, you should consider multiple measures. Remember, the most important thing is that you should have a good biological explanation for each signature. The best solution in study may not be the best solution in math. Method 1: Extract Signatures After selecting a proper signature, you can now extract signatures. In general, use 30~50 NMF runs will get a robust result. mt_sig &lt;- sig_extract(mt_tally$nmf_matrix, n_sig = 3, nrun = 10, cores = 4, pConstant = 1e-13 ) Method 2: Auto-extract If you have no idea to select a optimal signature number from technologies above, you can try auto-extract feature here. It uses a bayesian variant of NMF algorithm. You need to set a maximum signature number (default is 25) and run times to get the result. mt_sig2 &lt;- sig_auto_extract(mt_tally$nmf_matrix, K0 = 10, nrun = 10) At default, the code will use ‘robust’ strategy to return the result (see strategy option). It means that if you run 10 times and 6 of them return 4 signatures, then the optimal result with 4 signatures will be returned. The info of each run can be given as: mt_sig2$Raw$summary_run #&gt; # A tibble: 10 x 4 #&gt; Run K posterior file #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 9 2 1813. &quot;D:/Tool/Rtmp\\\\RtmpURv3Ba/BayesNMF.9.rds&quot; #&gt; 2 6 3 1776. &quot;D:/Tool/Rtmp\\\\RtmpURv3Ba/BayesNMF.6.rds&quot; #&gt; 3 3 2 1775. &quot;D:/Tool/Rtmp\\\\RtmpURv3Ba/BayesNMF.3.rds&quot; #&gt; 4 5 3 1745. &quot;D:/Tool/Rtmp\\\\RtmpURv3Ba/BayesNMF.5.rds&quot; #&gt; 5 8 4 1732. &quot;D:/Tool/Rtmp\\\\RtmpURv3Ba/BayesNMF.8.rds&quot; #&gt; 6 7 4 1702. &quot;D:/Tool/Rtmp\\\\RtmpURv3Ba/BayesNMF.7.rds&quot; #&gt; 7 1 4 1684. &quot;D:/Tool/Rtmp\\\\RtmpURv3Ba/BayesNMF.1.rds&quot; #&gt; 8 4 4 1661. &quot;D:/Tool/Rtmp\\\\RtmpURv3Ba/BayesNMF.4.rds&quot; #&gt; 9 10 4 1658. &quot;D:/Tool/Rtmp\\\\RtmpURv3Ba/BayesNMF.10.rds&quot; #&gt; 10 2 5 1652. &quot;D:/Tool/Rtmp\\\\RtmpURv3Ba/BayesNMF.2.rds&quot; Match Signatures After extracting signatures, we need to know their etiologies. This can be done by comparing the identified signatures and reference signatures from COSMIC database. sim &lt;- get_sig_similarity(mt_sig) #&gt; -Comparing against COSMIC signatures #&gt; ------------------------------------ #&gt; --Found Sig1 most similar to COSMIC_6 #&gt; Aetiology: defective DNA mismatch repair [similarity: 0.667] #&gt; --Found Sig2 most similar to COSMIC_1 #&gt; Aetiology: spontaneous deamination of 5-methylcytosine [similarity: 0.84] #&gt; --Found Sig3 most similar to COSMIC_1 #&gt; Aetiology: spontaneous deamination of 5-methylcytosine [similarity: 0.922] #&gt; ------------------------------------ #&gt; Return result invisiblely. The result object sim is a list. str(sim) #&gt; List of 3 #&gt; $ similarity : num [1:3, 1:30] 0.612 0.84 0.922 0.212 0.172 0.105 0.362 0.327 0.236 0.295 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; .. ..$ : chr [1:3] &quot;Sig1&quot; &quot;Sig2&quot; &quot;Sig3&quot; #&gt; .. ..$ : chr [1:30] &quot;COSMIC_1&quot; &quot;COSMIC_2&quot; &quot;COSMIC_3&quot; &quot;COSMIC_4&quot; ... #&gt; $ aetiology_db:List of 1 #&gt; ..$ : chr [1:30] &quot;spontaneous deamination of 5-methylcytosine&quot; &quot;APOBEC Cytidine Deaminase (C&gt;T)&quot; &quot;defects in DNA-DSB repair by HR&quot; &quot;exposure to tobacco (smoking) mutagens&quot; ... #&gt; $ best_match :List of 3 #&gt; ..$ Sig1:List of 2 #&gt; .. ..$ aetiology : chr &quot;defective DNA mismatch repair&quot; #&gt; .. ..$ best_match: chr &quot;Best match: COSMIC_6 [similarity: 0.667]&quot; #&gt; ..$ Sig2:List of 2 #&gt; .. ..$ aetiology : chr &quot;spontaneous deamination of 5-methylcytosine&quot; #&gt; .. ..$ best_match: chr &quot;Best match: COSMIC_1 [similarity: 0.84]&quot; #&gt; ..$ Sig3:List of 2 #&gt; .. ..$ aetiology : chr &quot;spontaneous deamination of 5-methylcytosine&quot; #&gt; .. ..$ best_match: chr &quot;Best match: COSMIC_1 [similarity: 0.922]&quot; #&gt; - attr(*, &quot;class&quot;)= chr [1:2] &quot;similarity&quot; &quot;list&quot; From the result we can see that only one signature is clear. If you find unknow signatures in your study, you should explore the etiologies by other analyses and even experiments. The similarity matrix can be plotted. pheatmap::pheatmap(sim$similarity) You can also try the COSMIC signature database V3 with: sim_v3 &lt;- get_sig_similarity(mt_sig, sig_db = &quot;SBS&quot;) #&gt; -Comparing against COSMIC signatures #&gt; ------------------------------------ #&gt; --Found Sig1 most similar to SBS6 #&gt; Aetiology: defective DNA mismatch repair [similarity: 0.659] #&gt; --Found Sig2 most similar to SBS1 #&gt; Aetiology: spontaneous or enzymatic deamination of 5-methylcytosine [similarity: 0.796] #&gt; --Found Sig3 most similar to SBS1 #&gt; Aetiology: spontaneous or enzymatic deamination of 5-methylcytosine [similarity: 0.905] #&gt; ------------------------------------ #&gt; Return result invisiblely. Operate Signature The result of sig_extract() or sig_auto_extract() is a list with Signature class. You can use $ or use operation function to obtain the data stored in it. To get the signature matrix: # Or mt_sig$Signature sig_signature(mt_sig)[1:5, ] #&gt; Sig1 Sig2 Sig3 #&gt; A[C&gt;A]A 2.573440e-03 5.328563e-03 1.452366e-02 #&gt; A[C&gt;A]C 5.615313e-19 4.431593e-02 2.663616e-14 #&gt; A[C&gt;A]G 1.456309e-15 6.330847e-03 1.252344e-14 #&gt; A[C&gt;A]T 9.651010e-15 4.254580e-15 1.142587e-02 #&gt; C[C&gt;A]A 6.955815e-03 2.937405e-14 2.005539e-02 To get signature exposure matrix: # Or mt_sig$Exposure sig_exposure(mt_sig)[, 1:5] #&gt; TCGA-AB-2802 TCGA-AB-2803 TCGA-AB-2804 TCGA-AB-2805 TCGA-AB-2806 #&gt; Sig1 5.951574e+00 6.874475e+00 8.830048e-13 2.457190e-13 1.764339e-12 #&gt; Sig2 2.106827e-12 7.125541e+00 1.593764e+00 6.964313e+00 3.483714e-12 #&gt; Sig3 4.048419e+00 9.300760e-14 3.406233e+00 7.035688e+00 1.299997e+01 get_sig_exposure() may be more useful, it can be used to return a data.frame and set an exposure threshold. get_sig_exposure(mt_sig) #&gt; sample Sig1 Sig2 Sig3 #&gt; 1: TCGA-AB-2802 5.951574e+00 2.106827e-12 4.048419e+00 #&gt; 2: TCGA-AB-2803 6.874475e+00 7.125541e+00 9.300760e-14 #&gt; 3: TCGA-AB-2804 8.830048e-13 1.593764e+00 3.406233e+00 #&gt; 4: TCGA-AB-2805 2.457190e-13 6.964313e+00 7.035688e+00 #&gt; 5: TCGA-AB-2806 1.764339e-12 3.483714e-12 1.299997e+01 #&gt; --- #&gt; 184: TCGA-AB-3007 1.014093e-12 4.575247e+00 2.424758e+00 #&gt; 185: TCGA-AB-3008 1.294223e-11 4.000009e+00 3.528735e-12 #&gt; 186: TCGA-AB-3009 8.818428e+00 7.079667e+00 1.910188e+01 #&gt; 187: TCGA-AB-3011 5.000001e+00 4.441747e-11 1.666433e-11 #&gt; 188: TCGA-AB-3012 1.385718e-13 2.810821e+00 3.189179e+00 For plotting signature profile and exposure profile, please go to chapter 4. References "],
["cnsig.html", "Chapter 2 Copy Number Signature Identification Introduction Read Data Tally Components Extract Signatures", " Chapter 2 Copy Number Signature Identification Introduction Unlike several mutation types presented in current COSMIC database for generating mutational signatures, it is hard to represent copy number features and generate the matrix for NMF decomposition. Macintyre et al. (2018) created a new method to generate the matrix for extracting signature by non-negative matrix factorization (NMF) algorithm. The steps are: derive 6 copy number features from absolute copy number profile apply mixture modelling to breakdown each feature distribution into mixtures of Gaussian or mixtures of Poisson distributions generate a sample-by-component matrix representing the sum of posterior probabilities of each copy-number event being assigned to each component. Based on previous work, our group devised a new method which discards the statistical modeling and create a fixed number of predefined components from 8 copy number features to generate the matrix as the input of NMF, it is easier to reproduce the result, apply to different cancer types and compare results. To test if the method would works, we applied it to prostate cancer and successfully identified 5 copy number signatures. Currently, there are few studies focus on copy number signatures and no reference signature database for matching and explaining the etiologies. If you study them, you should do extra work to explore and validate them. Furthermore, the input absolute copy number data may be generated by different methods and platforms, it is normal that the contribution of some copy number feature components varies a little and result in relatively lower signature similarity when comparing different cohorts or different copy number profile generation methods. Read Data The input requires absolute copy number profile with following information: Segment chromosome. Segment start. Segment end. Segment value: must be integer. Sample ID. The input data can be result from any softwares which provides information above. For chip data/segmentation data (copy ratio is available), ABSOLUTE is recommended. For raw sequencing data, Sequenza and FACETS are recommended. The import work is done by read_copynumber, this function supports data.frame or file, and even result directory from ABSOLUTE. # Load toy dataset of absolute copynumber profile load(system.file(&quot;extdata&quot;, &quot;toy_segTab.RData&quot;, package = &quot;sigminer&quot;, mustWork = TRUE )) cn &lt;- read_copynumber(segTabs, seg_cols = c(&quot;chromosome&quot;, &quot;start&quot;, &quot;end&quot;, &quot;segVal&quot;), genome_build = &quot;hg19&quot;, complement = FALSE, verbose = TRUE ) #&gt; Treating input as a data frame... #&gt; Checking chromosome names... #&gt; Segments info: #&gt; Keep - 467 #&gt; Filter - 0 #&gt; Joining adjacent segments with same copy number value... #&gt; Anotating... #&gt; #&gt; Summarizing per sample... #&gt; Done! cn #&gt; An object of class CopyNumber #&gt; ============================= #&gt; sample n_of_seg n_of_cnv n_of_amp n_of_del n_of_vchr cna_burden #&gt; 1: TCGA-DF-A2KN-01A-11D-A17U-01 33 6 5 1 4 0.000 #&gt; 2: TCGA-19-2621-01B-01D-0911-01 33 8 5 3 5 0.099 #&gt; 3: TCGA-B6-A0X5-01A-21D-A107-01 28 8 4 4 2 0.087 #&gt; 4: TCGA-A8-A07S-01A-11D-A036-01 38 11 2 9 4 0.112 #&gt; 5: TCGA-26-6174-01A-21D-1842-01 43 13 8 5 8 0.119 #&gt; 6: TCGA-CV-7432-01A-11D-2128-01 40 16 7 9 9 0.198 #&gt; 7: TCGA-06-0644-01A-02D-0310-01 46 19 5 14 8 0.165 #&gt; 8: TCGA-A5-A0G2-01A-11D-A042-01 39 21 5 16 10 0.393 #&gt; 9: TCGA-99-7458-01A-11D-2035-01 48 26 10 16 13 0.318 #&gt; 10: TCGA-05-4417-01A-22D-1854-01 52 37 33 4 17 0.654 Tally Components Currently, there are two methods for generating sample-by-component matrix, i.e. “W” or “M”. Options sigminer.sex and sigminer.copynumber.max are used to control the processing of sex and max values. Run ?sig_tally to see more. options(sigminer.sex = &quot;male&quot;, sigminer.copynumber.max = 10) # Load copy number object load(system.file(&quot;extdata&quot;, &quot;toy_copynumber.RData&quot;, package = &quot;sigminer&quot;, mustWork = TRUE )) # Use method designed by Wang, Shixiang et al. cn_tally_W &lt;- sig_tally(cn, method = &quot;W&quot;) # Use method designed by Macintyre et al. cn_tally_M &lt;- sig_tally(cn, method = &quot;M&quot;) This step return a list containing information about copy number features, components and matrix for NMF etc. Extract Signatures When you get the matrix, you can just do the signature extractin as SBS signatures. So here we won’t talk much. cn_tally_W$nmf_matrix[1:5, 1:5] #&gt; BP10MB[0] BP10MB[1] BP10MB[2] BP10MB[3] BP10MB[4] #&gt; TCGA-05-4417-01A-22D-1854-01 275 20 5 0 0 #&gt; TCGA-06-0644-01A-02D-0310-01 289 5 4 0 1 #&gt; TCGA-19-2621-01B-01D-0911-01 294 2 3 1 0 #&gt; TCGA-26-6174-01A-21D-1842-01 288 4 7 1 0 #&gt; TCGA-99-7458-01A-11D-2035-01 284 9 5 1 1 # library(NMF) sig_w &lt;- sig_extract(cn_tally_W$nmf_matrix, n_sig = 2, pConstant = 1e-13) References "],
["part-object-visualization.html", "(PART) Object Visualization", " (PART) Object Visualization "],
["cnobject.html", "Chapter 3 CopyNumber Object Profile Distribution", " Chapter 3 CopyNumber Object Profile show_cn_profile(cn, nrow = 2, ncol = 1) show_cn_circos(cn, samples = 1) Distribution show_cn_distribution(cn, mode = &quot;ld&quot;) show_cn_distribution(cn, mode = &quot;cd&quot;) "],
["sigobject.html", "Chapter 4 Signature Object Signature Profile Exposure Profile Consensus Map", " Chapter 4 Signature Object Signature is a core object in sigminer, it stores signatures and their exposures. Here we show how to plot signature profile and exposure profile. The result plots are basically ggplot based, so they can be further edited by your custom operations with ggplot grammar. Signature Profile A signature is composed of distinct component patterns. They can be shown by show_sig_profile(). Of note, for different types of signature, the bar heights may have different meanings. SBS signatures are displayed based on the observed component frequency of the human genome, i.e., representing the relative proportions of mutations generated by each signature based on the actual trinucleotide frequencies of the reference human genome. Similar to SBS signatures, copy number signatures are displayed based on the observed component frequency of the human genome. Of note, considering the count process of each feature is relatively independent, the profile is row normalized by each feature, unlike Macintyre et al. (2018) did column normalization (this method is easy to mislead readers), so the bar height can be compared within/between features. SBS Signature profile show_sig_profile(mt_sig, mode = &quot;SBS&quot;, paint_axis_text = FALSE) show_sig_profile(mt_sig, mode = &quot;SBS&quot;, style = &quot;cosmic&quot;) Copy Number Signature Porfile For copy number signatures from tally method “W”, you have to specify the normalize option as “feature”, so the bar heights can be more clearly compared. show_sig_profile(sig_w, mode = &quot;copynumber&quot;, normalize = &quot;feature&quot;, method = &quot;W&quot;, style = &quot;cosmic&quot; ) COSMIC Signature Profile Users can show profile of COSMIC signatures by show_cosmic_sig_profile(). Currently support v2 and SBS from v3. To see valid signature numbers, run show_cosmic_sig_profile(sig_db = &quot;legacy&quot;) #&gt; #&gt; Valid index for db &#39;legacy&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 show_cosmic_sig_profile(sig_db = &quot;legacy&quot;) #&gt; #&gt; Valid index for db &#39;legacy&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 To show the plot, specify signature shortnames to sig_index option. show_cosmic_sig_profile(sig_index = c(1, 5, 6), style = &quot;cosmic&quot;) #&gt; #&gt; Valid index for db &#39;legacy&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Exposure Profile show_sig_exposure(mt_sig) show_sig_exposure(mt_sig, style = &quot;cosmic&quot;) show_sig_exposure(sig_w, style = &quot;cosmic&quot;) Of note: For SBS signature, the absolute exposure is the estimated SBS count. For copy number signatures, the absolute exposure is the estimated copy number segments. Consensus Map This can only support the result from sig_extract() with multiple runs. show_sig_consensusmap(mt_sig) "],
["part-signature-analysis-and-visualization.html", "(PART) Signature Analysis and Visualization", " (PART) Signature Analysis and Visualization "],
["association-analysis.html", "Chapter 5 Association Analysis and Visualization", " Chapter 5 Association Analysis and Visualization "],
["group-analysis.html", "Chapter 6 Group Analysis and Visualization Group Generation Group Comparison Analysis Group Visualization", " Chapter 6 Group Analysis and Visualization Group analysis is a common task in cancer study. sigminer supports dividing samples into multiple groups and comparing genotype/phenotype feature measures. Group Generation There are multiple methods to generate groups, including ‘consensus’ (default, can be only used by result from sig_extract()), ‘k-means’ etc. After determining groups, sigminer will assign each group to a signature with maximum fraction. We may say a group is Sig_x enriched. mt_grps &lt;- get_groups(mt_sig, method = &quot;consensus&quot;, match_consensus = TRUE) #&gt; =&gt; Obtaining clusters from the hierarchical clustering of the consensus matrix... #&gt; =&gt; Finding the dominant signature of each group... #&gt; =&gt; Generating a table of group and dominant signature: #&gt; #&gt; Sig1 Sig2 Sig3 #&gt; 1 9 43 39 #&gt; 2 14 6 8 #&gt; 3 28 12 29 #&gt; =&gt; Assigning a group to a signature with the maxium fraction (stored in &#39;map_table&#39; attr)... #&gt; =&gt; Summarizing... #&gt; group #1: 91 samples with Sig2 enriched. #&gt; group #2: 28 samples with Sig1 enriched. #&gt; group #3: 69 samples with Sig3 enriched. head(mt_grps) #&gt; sample group silhouette_width enrich_sig #&gt; 1: TCGA-AB-2977 1 0.1810 Sig2 #&gt; 2: TCGA-AB-2867 1 -0.0231 Sig2 #&gt; 3: TCGA-AB-2832 1 0.2290 Sig2 #&gt; 4: TCGA-AB-2925 1 0.4080 Sig2 #&gt; 5: TCGA-AB-3009 1 0.3130 Sig2 #&gt; 6: TCGA-AB-2881 1 0.2850 Sig2 The returned sample orders match sample orders in clustered consensus matrix. show_sig_consensusmap(mt_sig) Sometimes, the mapping between groups and enriched signatures may not right. Users should check it and even correct it manually. attr(mt_grps, &quot;map_table&quot;) #&gt; #&gt; Sig1 Sig2 Sig3 #&gt; 1 9 43 39 #&gt; 2 14 6 8 #&gt; 3 28 12 29 Group Comparison Analysis Group Visualization "],
["part-others.html", "(PART) Others", " (PART) Others "],
["datasets.html", "Chapter 7 Datasets Reference Annotation Copy Number components setting", " Chapter 7 Datasets Reference Annotation sigminer stores many reference annotation datasets for internal calculation. It can be exported for other usage either by data() or get_genome_annotation(). Currently, there are the following datasets: centromeres.hg19 centromeres.hg38 chromsize.hg19 chromsize.hg38 cytobands.hg19 cytobands.hg38 An example is given as below: data(&quot;centromeres.hg19&quot;) head(centromeres.hg19) #&gt; chrom left.base right.base #&gt; 1 chr1 121535434 124535434 #&gt; 2 chr2 92326171 95326171 #&gt; 3 chr3 90504854 93504854 #&gt; 4 chr4 49660117 52660117 #&gt; 5 chr5 46405641 49405641 #&gt; 6 chr6 58830166 61830166 get_genome_annotation() can better control the returned data.frame. get_genome_annotation( data_type = &quot;chr_size&quot;, chrs = c(&quot;chr1&quot;, &quot;chr10&quot;, &quot;chr20&quot;), genome_build = &quot;hg19&quot; ) #&gt; chrom size #&gt; 1 chr1 249250621 #&gt; 2 chr10 135534747 #&gt; 3 chr20 63025520 More see ?get_genome_annotation. Copy Number components setting Dataset CN.features is a predefined component data table for identifying copy number signatures by method “Wang”. Users can define a custom table with similar structure and pass it to function like sig_tally(). Detail about how to generate this dataset can be viewed at https://github.com/ShixiangWang/sigminer/blob/master/data-raw/CN-features.R. CN.features #&gt; feature component label min max #&gt; 1: BP10MB BP10MB[0] point 0 0 #&gt; 2: BP10MB BP10MB[1] point 1 1 #&gt; 3: BP10MB BP10MB[2] point 2 2 #&gt; 4: BP10MB BP10MB[3] point 3 3 #&gt; 5: BP10MB BP10MB[4] point 4 4 #&gt; 6: BP10MB BP10MB[5] point 5 5 #&gt; 7: BP10MB BP10MB[&gt;5] range 5 Inf #&gt; 8: BPArm BPArm[0] point 0 0 #&gt; 9: BPArm BPArm[1] point 1 1 #&gt; 10: BPArm BPArm[2] point 2 2 #&gt; 11: BPArm BPArm[3] point 3 3 #&gt; 12: BPArm BPArm[4] point 4 4 #&gt; 13: BPArm BPArm[5] point 5 5 #&gt; 14: BPArm BPArm[6] point 6 6 #&gt; 15: BPArm BPArm[7] point 7 7 #&gt; 16: BPArm BPArm[8] point 8 8 #&gt; 17: BPArm BPArm[9] point 9 9 #&gt; 18: BPArm BPArm[10] point 10 10 #&gt; 19: BPArm BPArm[&gt;10 &amp; &lt;=20] range 10 20 #&gt; 20: BPArm BPArm[&gt;20 &amp; &lt;=30] range 20 30 #&gt; 21: BPArm BPArm[&gt;30] range 30 Inf #&gt; 22: CN CN[0] point 0 0 #&gt; 23: CN CN[1] point 1 1 #&gt; 24: CN CN[2] point 2 2 #&gt; 25: CN CN[3] point 3 3 #&gt; 26: CN CN[4] point 4 4 #&gt; 27: CN CN[&gt;4 &amp; &lt;=8] range 4 8 #&gt; 28: CN CN[&gt;8] range 8 Inf #&gt; 29: CNCP CNCP[0] point 0 0 #&gt; 30: CNCP CNCP[1] point 1 1 #&gt; 31: CNCP CNCP[2] point 2 2 #&gt; 32: CNCP CNCP[3] point 3 3 #&gt; 33: CNCP CNCP[4] point 4 4 #&gt; 34: CNCP CNCP[&gt;4 &amp; &lt;=8] range 4 8 #&gt; 35: CNCP CNCP[&gt;8] range 8 Inf #&gt; 36: OsCN OsCN[0] point 0 0 #&gt; 37: OsCN OsCN[1] point 1 1 #&gt; 38: OsCN OsCN[2] point 2 2 #&gt; 39: OsCN OsCN[3] point 3 3 #&gt; 40: OsCN OsCN[4] point 4 4 #&gt; 41: OsCN OsCN[&gt;4 &amp; &lt;=10] range 4 10 #&gt; 42: OsCN OsCN[&gt;10] range 10 Inf #&gt; 43: SS SS[&lt;=2] range -Inf 2 #&gt; 44: SS SS[&gt;2 &amp; &lt;=3] range 2 3 #&gt; 45: SS SS[&gt;3 &amp; &lt;=4] range 3 4 #&gt; 46: SS SS[&gt;4 &amp; &lt;=5] range 4 5 #&gt; 47: SS SS[&gt;5 &amp; &lt;=6] range 5 6 #&gt; 48: SS SS[&gt;6 &amp; &lt;=7] range 6 7 #&gt; 49: SS SS[&gt;7 &amp; &lt;=8] range 7 8 #&gt; 50: SS SS[&gt;8] range 8 Inf #&gt; 51: NC50 NC50[&lt;=2] range -Inf 2 #&gt; 52: NC50 NC50[3] point 3 3 #&gt; 53: NC50 NC50[4] point 4 4 #&gt; 54: NC50 NC50[5] point 5 5 #&gt; 55: NC50 NC50[6] point 6 6 #&gt; 56: NC50 NC50[7] point 7 7 #&gt; 57: NC50 NC50[&gt;7] range 7 Inf #&gt; 58: BoChr BoChr[1] point 1 1 #&gt; 59: BoChr BoChr[2] point 2 2 #&gt; 60: BoChr BoChr[3] point 3 3 #&gt; 61: BoChr BoChr[4] point 4 4 #&gt; 62: BoChr BoChr[5] point 5 5 #&gt; 63: BoChr BoChr[6] point 6 6 #&gt; 64: BoChr BoChr[7] point 7 7 #&gt; 65: BoChr BoChr[8] point 8 8 #&gt; 66: BoChr BoChr[9] point 9 9 #&gt; 67: BoChr BoChr[10] point 10 10 #&gt; 68: BoChr BoChr[11] point 11 11 #&gt; 69: BoChr BoChr[12] point 12 12 #&gt; 70: BoChr BoChr[13] point 13 13 #&gt; 71: BoChr BoChr[14] point 14 14 #&gt; 72: BoChr BoChr[15] point 15 15 #&gt; 73: BoChr BoChr[16] point 16 16 #&gt; 74: BoChr BoChr[17] point 17 17 #&gt; 75: BoChr BoChr[18] point 18 18 #&gt; 76: BoChr BoChr[19] point 19 19 #&gt; 77: BoChr BoChr[20] point 20 20 #&gt; 78: BoChr BoChr[21] point 21 21 #&gt; 79: BoChr BoChr[22] point 22 22 #&gt; 80: BoChr BoChr[23] point 23 23 #&gt; feature component label min max "],
["references.html", "References", " References Alexandrov, Ludmil B, Jaegil Kim, Nicholas J Haradhvala, Mi Ni Huang, Alvin Wei Tian Ng, Yang Wu, Arnoud Boot, et al. 2020. “The Repertoire of Mutational Signatures in Human Cancer.” Nature 578 (7793): 94–101. Gaujoux, Renaud, and Cathal Seoighe. 2010. “A Flexible R Package for Nonnegative Matrix Factorization.” BMC Bioinformatics 11 (1): 367. Kim, Jaegil, Kent W Mouw, Paz Polak, Lior Z Braunstein, Atanas Kamburov, Grace Tiao, David J Kwiatkowski, et al. 2016. “Somatic Ercc2 Mutations Are Associated with a Distinct Genomic Signature in Urothelial Tumors.” Nature Genetics 48 (6): 600. Macintyre, Geoff, Teodora E Goranova, Dilrini De Silva, Darren Ennis, Anna M Piskorz, Matthew Eldridge, Daoud Sie, et al. 2018. “Copy Number Signatures and Mutational Processes in Ovarian Carcinoma.” Nature Genetics 50 (9): 1262–70. Mayakonda, Anand, De-Chen Lin, Yassen Assenov, Christoph Plass, and H Phillip Koeffler. 2018. “Maftools: Efficient and Comprehensive Analysis of Somatic Variants in Cancer.” Genome Research 28 (11): 1747–56. Tan, Vincent YF, and Cédric Févotte. 2012. “Automatic Relevance Determination in Nonnegative Matrix Factorization with the/Spl Beta/-Divergence.” IEEE Transactions on Pattern Analysis and Machine Intelligence 35 (7): 1592–1605. "]
]
