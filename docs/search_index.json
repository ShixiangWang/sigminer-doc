[
["index.html", "Sigminer: A Scalable Toolkit to Extract, Analyze and Visualize Mutational Signatures Chapter 1 Introduction 1.1 Biological Significance of Mutational Signature 1.2 Sigminer 1.3 Installation 1.4 Issues or Suggestions 1.5 Preparation 1.6 Overview of Contents 1.7 Citation and LICENSE", " Sigminer: A Scalable Toolkit to Extract, Analyze and Visualize Mutational Signatures Shixiang Wang, ShanghaiTech University Xue-Song Liu, ShanghaiTech University last revised on 2020-10-09 Chapter 1 Introduction Underlying cancer hallmarks are genome instability, which generates the genetic diversity that expedites their acquisition, and inflammation, which fosters multiple hallmark functions (Hanahan 2011). Cancer genomes typically harbors more than 1,000 mutations in small (e.g., point mutations, short insertions and deletions) and large scale (e.g., copy number variations, rearrangements). Genomic contexts where mutation may accumulate in response to both endogenous processes and exogeneous exposures. In recent years, computational approaches (typically non-negative matrix factorization (NMF)) have been applied to the mutation catalog analysis of human/mouse tumors to detect characteristic mutational patterns, also known as “mutational signatures”. 1.1 Biological Significance of Mutational Signature To illustrate the biological significance of mutational signatures, we show some well organized figures here. Figure 1.1: The illustration of SBS signature, fig source: https://www.nature.com/articles/nrg3729 Figure 1.2: The illustration of SBS signature (2), fig source: https://www.nature.com/articles/s41467-018-05228-y SBS (short for single base substitution) signature is a famous type of mutational signature. SBS signatures are well studied and related to single-strand changes, typically caused by defective DNA repair. Common etiologies contain aging, defective DNA mismatch repair, smoking, ultraviolet light exposure and APOBEC. Currently, all SBS signatures are summarized in COSMIC database, including two versions: v2 and v3. Recently, Alexandrov et al. (2020) extends the concept of mutational signature to three types of alteration: SBS, DBS (short for doublet base substitution) and INDEL (short for short insertion and deletion). All reported common signatures are recorded in COSMIC (https://cancer.sanger.ac.uk/cosmic/signatures/), so we usually call them COSMIC signatures. Figure 1.3: The illustration of copy number signatures, fig source: https://www.nature.com/articles/s41588-018-0212-y Copy number signatures are less studied and many works are still to be done. The introduction is described in Chapter 3. Genome rearrangement signatures are limited to whole genome sequencing data and also less studied, the implementation is not available in current version of Sigminer. We are happy to accept a PR if you are interested in create an extension function to Sigminer. More details about mutational signatures you can read the wiki page. 1.2 Sigminer Here, we present an easy-to-use and scalable toolkit for mutational signature analysis and visualization in R. We named it sigminer (signature + miner). This tool can help users to extract, analyze and visualize signatures from genomic alteration records, thus providing new insight into cancer study. Currently, sigminer supports four types of signature: SBS signature in the form of 96 (6, 24, 384, 1536 and 6144) components. DBS signature in the form of 78 (186) components. ID (INDEL) signature in the form of 83 (28) components. Copy number signature by the method either from Macintyre et al. (2018) or from our group work (Wang et al. 2020). Component here refer to a classification for a record (e.g. a mutation), in some papers mutation type or just type means the same thing. We use ‘component’ to represent a more broad concept. 1.3 Installation The stable release version of sigminer package can be installed from the CRAN: install.packages(&quot;sigminer&quot;, dependencies = TRUE) # Or BiocManager::install(&quot;sigminer&quot;, dependencies = TRUE) Set dependencies = TRUE is recommended because many packages are required for full features in sigminer. The development version of sigminer package can be installed from Github: # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;ShixiangWang/sigminer&quot;, dependencies = TRUE) 1.4 Issues or Suggestions Any issue or suggestion can be posted on GitHub issue, we will reply ASAP. Any pull requrest is welcome. 1.5 Preparation To reproduce the examples shown in this manual, users should load the following packages firstly. sigminer is requred to have version &gt;= 1.0.0. library(sigminer) library(NMF) Current manual uses sigminer 1.0.19. More info about sigminer can be given as: hello() #&gt; Thanks for using &#39;sigminer&#39; package! #&gt; ========================================================================= #&gt; Version: 1.0.19 #&gt; Run citation(&#39;sigminer&#39;) to see how to cite sigminer in publications. #&gt; #&gt; Project home : https://github.com/ShixiangWang/sigminer #&gt; Bug report : https://github.com/ShixiangWang/sigminer/issues #&gt; Documentation: https://shixiangwang.github.io/sigminer-doc/ #&gt; ========================================================================= #&gt; 1.6 Overview of Contents The contents of this manual have been divided into 4 sections: Common workflow. de novo signature discovery. single sample exposure quantification. subtype prediction. Target visualization. copy number profile. copy number distribution. catalogue profile. signature profile. exposure profile. … Universal analysis. association analysis. group analysis. Other utilities. All functions are well organized and documented at https://shixiangwang.github.io/sigminer/reference/index.html (For Chinese users, you can also read it at https://shixiangwang.gitee.io/sigminer/reference/index.html). For usage of a specific function fun, run ?fun in your R console to see its documentation. 1.7 Citation and LICENSE citation(&quot;sigminer&quot;) #&gt; #&gt; To cite sigminer in publications use: #&gt; #&gt; Wang, Shixiang, et al. &quot;Copy number signature analyses in prostate cancer reveal #&gt; distinct etiologies and clinical outcomes&quot; medRxiv (2020). #&gt; #&gt; A BibTeX entry for LaTeX users is #&gt; #&gt; @Article{, #&gt; title = {Copy number signature analyses in prostate cancer reveal distinct etiologies and clinical outcomes}, #&gt; author = {Shixiang Wang and Huimin Li and Minfang Song and Zaoke He and Tao Wu and Xuan Wang and Ziyu Tao and Kai Wu and Xue-Song Liu}, #&gt; journal = {medRxiv}, #&gt; year = {2020}, #&gt; url = {https://www.medrxiv.org/content/10.1101/2020.04.27.20082404v1}, #&gt; } The software is made available for non commercial research purposes only under the MIT. However, notwithstanding any provision of the MIT License, the software currently may not be used for commercial purposes without explicit written permission after contacting Shixiang Wang wangshx@shanghaitech.edu.cn or Xue-Song Liu liuxs@shanghaitech.edu.cn. MIT © 2019-2020 Shixiang Wang, Xue-Song Liu MIT © 2018 Geoffrey Macintyre MIT © 2018 Anand Mayakonda Cancer Biology Group @ShanghaiTech Research group led by Xue-Song Liu in ShanghaiTech University References "],
["sbssig.html", "Chapter 2 COSMIC Signature Identification 2.1 Read Data 2.2 Tally Components 2.3 Extract Signatures 2.4 Match Signatures 2.5 Operate Signature", " Chapter 2 COSMIC Signature Identification In this chapter, we will introduce how to identify COSMIC signatures from records of variant calling data. The COSMIC signatures include three type of signatures: SBS, DBS and ID (short for INDEL). The signature identification procedure has been divided into 3 steps: Read mutation data. Tally components: for SBS, it means classifying SBS records into 96 components (the most common case) and generate sample matrix. Extract signatures: estimate signature number and identify signatures. 2.1 Read Data Make sure library(sigminer) before running the following code. The input data should be in VCF, MAF format. For VCF, it can only be VCF file paths. For MAF, it can be either a MAF file or a data.frame. MAF format is the standard way to represent small-scale variants in Sigminer. There is a popular R/Bioconductor package maftools (Mayakonda et al. 2018) for analyzing MAF data. It provides an R class MAF to represent MAF format data. 2.1.1 VCF as input If you use VCF files as input, you can use read_vcf() to read multiple VCF files as a MAF object. vcfs &lt;- list.files(system.file(&quot;extdata&quot;, package = &quot;sigminer&quot;), &quot;*.vcf&quot;, full.names = TRUE) maf &lt;- read_vcf(vcfs) #&gt; Reading file(s): /Users/wsx/Library/R/sigminer/extdata/test1.vcf, /Users/wsx/Library/R/sigminer/extdata/test2.vcf, /Users/wsx/Library/R/sigminer/extdata/test3.vcf #&gt; Annotating Variant Type... #&gt; Annotating mutations to first matched gene based on database /Users/wsx/Library/R/sigminer/extdata/human_hg19_gene_info.rds... #&gt; Transforming into a MAF object... #&gt; -Validating #&gt; --Non MAF specific values in Variant_Classification column: #&gt; Unknown #&gt; -Summarizing #&gt; -Processing clinical data #&gt; --Missing clinical data #&gt; -Finished in 0.100s elapsed (0.046s cpu) maf &lt;- read_vcf(vcfs, keep_only_pass = FALSE) #&gt; Reading file(s): /Users/wsx/Library/R/sigminer/extdata/test1.vcf, /Users/wsx/Library/R/sigminer/extdata/test2.vcf, /Users/wsx/Library/R/sigminer/extdata/test3.vcf #&gt; Annotating Variant Type... #&gt; Annotating mutations to first matched gene based on database /Users/wsx/Library/R/sigminer/extdata/human_hg19_gene_info.rds... #&gt; Transforming into a MAF object... #&gt; -Validating #&gt; --Non MAF specific values in Variant_Classification column: #&gt; Unknown #&gt; -Summarizing #&gt; -Processing clinical data #&gt; --Missing clinical data #&gt; -Finished in 0.119s elapsed (0.064s cpu) 2.1.2 MAF as input MAF format is the most recommended input, you can provides it either as a file or as a data.frame. Typically, you can obtain the data in the following ways: You get multiple VCF files and convert them into a MAF file (vcf2maf is the most used tool for conversion). You get a MAF file from a reference or a public data portal, e.g., cBioPortal or GDC portal. You get a EXCEL file providing MAF-like data from a reference, you should read the data firstly (with readxl::read_excel()) and then construct a data.frame providing necessary columns. Once a MAF file or a MAF-like data.frame is ready, you can read/convert it as a MAF object with read_maf(). Here TCGA LAML dataset is used as an example: laml.maf &lt;- system.file(&quot;extdata&quot;, &quot;tcga_laml.maf.gz&quot;, package = &quot;maftools&quot;, mustWork = TRUE) laml &lt;- read_maf(maf = laml.maf) #&gt; -Reading #&gt; -Validating #&gt; -Silent variants: 475 #&gt; -Summarizing #&gt; -Processing clinical data #&gt; --Missing clinical data #&gt; -Finished in 0.730s elapsed (0.312s cpu) laml #&gt; An object of class MAF #&gt; ID summary Mean Median #&gt; 1: NCBI_Build 37 NA NA #&gt; 2: Center genome.wustl.edu NA NA #&gt; 3: Samples 193 NA NA #&gt; 4: nGenes 1241 NA NA #&gt; 5: Frame_Shift_Del 52 0.269 0 #&gt; 6: Frame_Shift_Ins 91 0.472 0 #&gt; 7: In_Frame_Del 10 0.052 0 #&gt; 8: In_Frame_Ins 42 0.218 0 #&gt; 9: Missense_Mutation 1342 6.953 7 #&gt; 10: Nonsense_Mutation 103 0.534 0 #&gt; 11: Splice_Site 92 0.477 0 #&gt; 12: total 1732 8.974 9 The laml is a MAF object. The MAF class is exported from maftools to sigminer. So laml can be directly use functions provided by maftools. As a MAF object, the mutation records are stored in slot data and maf.silent. head(laml@data) #&gt; Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome Start_Position End_Position #&gt; 1: ABCA10 10349 genome.wustl.edu 37 17 67170917 67170917 #&gt; 2: ABCA4 24 genome.wustl.edu 37 1 94490594 94490594 #&gt; 3: ABCB11 8647 genome.wustl.edu 37 2 169780250 169780250 #&gt; 4: ABCC3 8714 genome.wustl.edu 37 17 48760974 48760974 #&gt; 5: ABCF1 23 genome.wustl.edu 37 6 30554429 30554429 #&gt; 6: ABCG4 64137 genome.wustl.edu 37 11 119031351 119031351 #&gt; Strand Variant_Classification Variant_Type Reference_Allele Tumor_Seq_Allele1 #&gt; 1: + Splice_Site SNP T T #&gt; 2: + Missense_Mutation SNP C C #&gt; 3: + Missense_Mutation SNP G G #&gt; 4: + Missense_Mutation SNP C C #&gt; 5: + Missense_Mutation SNP G G #&gt; 6: + Missense_Mutation SNP A A #&gt; Tumor_Seq_Allele2 Tumor_Sample_Barcode Protein_Change i_TumorVAF_WU i_transcript_name #&gt; 1: C TCGA-AB-2988 p.K960R 45.66000 NM_080282.3 #&gt; 2: T TCGA-AB-2869 p.R1517H 38.12000 NM_000350.2 #&gt; 3: A TCGA-AB-3009 p.A1283V 46.97218 NM_003742.2 #&gt; 4: T TCGA-AB-2887 p.P1271S 56.41000 NM_003786.1 #&gt; 5: A TCGA-AB-2920 p.G658S 40.95000 NM_001025091.1 #&gt; 6: G TCGA-AB-2934 p.Y567C 32.84000 NM_022169.1 head(laml@maf.silent) #&gt; Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome Start_Position End_Position #&gt; 1: ABCC11 85320 genome.wustl.edu 37 16 48244997 48244997 #&gt; 2: ACAN 176 genome.wustl.edu 37 15 89401084 89401084 #&gt; 3: ACAT1 38 genome.wustl.edu 37 11 108009744 108009744 #&gt; 4: ACCN2 41 genome.wustl.edu 37 12 50452780 50452780 #&gt; 5: ACTA2 59 genome.wustl.edu 37 10 90695109 90695109 #&gt; 6: ACTL9 284382 genome.wustl.edu 37 19 8808551 8808551 #&gt; Strand Variant_Classification Variant_Type Reference_Allele Tumor_Seq_Allele1 #&gt; 1: + Silent SNP G G #&gt; 2: + Silent SNP C C #&gt; 3: + Silent SNP T T #&gt; 4: + Silent SNP C C #&gt; 5: + Silent SNP C C #&gt; 6: + Silent SNP G G #&gt; Tumor_Seq_Allele2 Tumor_Sample_Barcode Protein_Change i_TumorVAF_WU i_transcript_name #&gt; 1: A TCGA-AB-2830 p.I490I 34.2700000 NM_032583.3 #&gt; 2: T TCGA-AB-2898 p.S1756S 38.3000000 NM_013227.2 #&gt; 3: G TCGA-AB-2887 p.T185T 49.0400000 NM_000019.3 #&gt; 4: G TCGA-AB-3009 p.L77L 48.1000000 NM_020039.2 #&gt; 5: T TCGA-AB-2973 p.P335P 0.2012072 NM_001613.1 #&gt; 6: A TCGA-AB-2936 p.F167F 46.1500000 NM_178525.3 The data slot contains non-silent variants, and the maf.silent slot contains silent variants. Default uses Variant Classifications with High/Moderate variant consequences as non-silent variants. http://asia.ensembl.org/Help/Glossary?id=535: “Frame_Shift_Del”, “Frame_Shift_Ins”, “Splice_Site”, “Translation_Start_Site”,“Nonsense_Mutation”, “Nonstop_Mutation”, “In_Frame_Del”,“In_Frame_Ins”, “Missense_Mutation” (see ?read_maf). If you want to change, please set vc_nonSyn option. Other slots in MAF object are summary data either by sample or gene/variant type etc. slotNames(laml) #&gt; [1] &quot;data&quot; &quot;variants.per.sample&quot; #&gt; [3] &quot;variant.type.summary&quot; &quot;variant.classification.summary&quot; #&gt; [5] &quot;gene.summary&quot; &quot;summary&quot; #&gt; [7] &quot;maf.silent&quot; &quot;clinical.data&quot; Acute myeloid leukemia is not a good object to study mutational signatures due to low mutation burden, we will use a subset of TCGA breast cohort as for illustration of the following analyses. Anand Mayakonda has already stored whole TCGA mutation data as MAF objects in TCGAmutations package. Here I will load the TCGA BRCA cohort and create a sub-cohort with 100 tumors. library(TCGAmutations) knitr::kable(tcga_available()) Study_Abbreviation Study_Name MC3 Firehose ACC Adrenocortical_carcinoma 92 62 [dx.doi.org/10.7908/C1610ZNC] BLCA Bladder_Urothelial_Carcinoma 411 395 [dx.doi.org/10.7908/C1MW2GGF] BRCA Breast_invasive_carcinoma 1020 978 [dx.doi.org/10.7908/C1TB167Z] CESC Cervical_squamous_cell_carcinoma_and_endocervical_adenocarcinoma 289 194 [dx.doi.org/10.7908/C1MG7NV6] CHOL Cholangiocarcinoma 36 35 [dx.doi.org/10.7908/C1K936V8] COAD Colon_adenocarcinoma 404 367 [dx.doi.org/10.7908/C1DF6QJD] DLBC Lymphoid_Neoplasm_Diffuse_Large_B-cell_Lymphoma 37 48 [dx.doi.org/10.7908/C1X066DK] ESCA Esophageal_carcinoma 184 185 [dx.doi.org/10.7908/C1BV7FZC] GBM Glioblastoma_multiforme 390 283 [dx.doi.org/10.7908/C1XG9QGN] HNSC Head_and_Neck_squamous_cell_carcinoma 507 511 [dx.doi.org/10.7908/C18C9VM5] KICH Kidney_Chromophobe 66 66 [dx.doi.org/10.7908/C1765DQK] KIRC Kidney_renal_clear_cell_carcinoma 369 476 [dx.doi.org/10.7908/C10864RM] KIRP Kidney_renal_papillary_cell_carcinoma 281 282 [dx.doi.org/10.7908/C19C6WTF] LAML Acute_Myeloid_Leukemia 140 193 [dx.doi.org/10.7908/C1D21X2X] LGG Brain_Lower_Grade_Glioma 511 516 [dx.doi.org/10.7908/C1MC8ZDF] LIHC Liver_hepatocellular_carcinoma 363 373 [dx.doi.org/10.7908/C128070B] LUAD Lung_adenocarcinoma 515 533 [dx.doi.org/10.7908/C17P8XT3] LUSC Lung_squamous_cell_carcinoma 485 178 [dx.doi.org/10.7908/C1X34WXV] MESO Mesothelioma 82 NA OV Ovarian_serous_cystadenocarcinoma 411 466 [dx.doi.org/10.7908/C1736QC5] PAAD Pancreatic_adenocarcinoma 177 126 [dx.doi.org/10.7908/C1513XNS] PCPG Pheochromocytoma_and_Paraganglioma 179 179 [dx.doi.org/10.7908/C13T9GN0] PRAD Prostate_adenocarcinoma 497 498 [dx.doi.org/10.7908/C1Z037MV] READ Rectum_adenocarcinoma 149 122 [dx.doi.org/10.7908/C1S46RDB] SARC Sarcoma 236 247 [dx.doi.org/10.7908/C137785M] SKCM Skin_Cutaneous_Melanoma 466 290 [dx.doi.org/10.7908/C1J67GCG] STAD Stomach_adenocarcinoma 439 393 [dx.doi.org/10.7908/C1C828SM] TGCT Testicular_Germ_Cell_Tumors 129 147 [dx.doi.org/10.7908/C1S1820D] THCA Thyroid_carcinoma 492 496 [dx.doi.org/10.7908/C16W99KN] THYM Thymoma 123 120 [dx.doi.org/10.7908/C15T3JZ6] UCEC Uterine_Corpus_Endometrial_Carcinoma 530 248 [dx.doi.org/10.7908/C1C828T2] UCS Uterine_Carcinosarcoma 57 57 [dx.doi.org/10.7908/C1PC31W8] UVM Uveal_Melanoma 80 80 [dx.doi.org/10.7908/C1S1821V] Unknown Samples_I_couldnt_figure_out_the_source 77 NA set.seed(1234) brca &lt;- tcga_load(&quot;BRCA&quot;) brca &lt;- maftools::subsetMaf(brca, tsb = as.character(sample(brca@variants.per.sample$Tumor_Sample_Barcode, 100)) ) saveRDS(brca, file = &quot;data/brca.rds&quot;) Here we save this cohort to let user can also run the examples without installing package TCGAmutations. brca &lt;- readRDS(&quot;data/brca.rds&quot;) 2.2 Tally Components 2.2.1 The most common 96 components According to 3-nucleotide context (mutated base, 5’ and 3’ adjacent bases) and base complementary pairing principle, we can divide all SBS mutations into 96 mutation types. We call each mutation type as a component here. This classification is based the six substitution subtypes: C&gt;A, C&gt;G, C&gt;T, T&gt;A, T&gt;C, and T&gt;G (all substitutions are referred to by the pyrimidine of the mutated Watson—Crick base pair). Further, each of the substitutions is examined by incorporating information on the bases immediately 5’ and 3’ to each mutated base generating 96 possible mutation types (6 types of substitution x 4 types of 5’ base x 4 types of 3’ base). Figure 2.1: The illustration of 96 components, fig source: https://en.wikipedia.org/wiki/Mutational_signatures We tally components in each sample, and generate a sample-by-component matrix. mt_tally &lt;- sig_tally( brca, ref_genome = &quot;BSgenome.Hsapiens.UCSC.hg19&quot;, useSyn = TRUE ) #&gt; [36mℹ[39m [2020-10-09 00:02:12]: Started. #&gt; [32m✓[39m [2020-10-09 00:02:12]: Reference genome loaded. #&gt; [32m✓[39m [2020-10-09 00:02:12]: Variants from MAF object queried. #&gt; [32m✓[39m [2020-10-09 00:02:12]: Chromosome names checked. #&gt; [32m✓[39m [2020-10-09 00:02:13]: Sex chromosomes properly handled. #&gt; [32m✓[39m [2020-10-09 00:02:13]: Only variants located in standard chromosomes (1:22, X, Y, M/MT) are kept. #&gt; [32m✓[39m [2020-10-09 00:02:13]: Variant start and end position checked. #&gt; [32m✓[39m [2020-10-09 00:02:13]: Variant data for matrix generation preprocessed. #&gt; [36mℹ[39m [2020-10-09 00:02:13]: SBS matrix generation - start. #&gt; [36mℹ[39m [2020-10-09 00:02:13]: Extracting 5&#39; and 3&#39; adjacent bases. #&gt; [36mℹ[39m [2020-10-09 00:02:15]: Extracting +/- 20bp around mutated bases for background C&gt;T estimation. #&gt; [36mℹ[39m [2020-10-09 00:02:15]: Estimating APOBEC enrichment scores. #&gt; [36mℹ[39m [2020-10-09 00:02:15]: Performing one-way Fisher&#39;s test for APOBEC enrichment. #&gt; [32m✓[39m [2020-10-09 00:02:15]: APOBEC related mutations are enriched in 28% of samples (APOBEC enrichment score &gt; 2; 28 of 100 samples) #&gt; [36mℹ[39m [2020-10-09 00:02:15]: Creating SBS sample-by-component matrices. #&gt; [32m✓[39m [2020-10-09 00:02:15]: SBS-6 matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:15]: SBS-96 matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:15]: SBS-1536 matrix created. #&gt; [36mℹ[39m [2020-10-09 00:02:15]: Return SBS-96 as major matrix. #&gt; [32m✓[39m [2020-10-09 00:02:15]: Done. #&gt; [36mℹ[39m [2020-10-09 00:02:15]: 3.024 secs elapsed. Here set useSyn = TRUE to include all variant records in MAF object to generate sample matrix. mt_tally$nmf_matrix[1:5, 1:5] #&gt; A[T&gt;C]A C[T&gt;C]A G[T&gt;C]A T[T&gt;C]A A[C&gt;T]A #&gt; TCGA-A1-A0SH-01A-11D-A099-09 0 0 1 1 0 #&gt; TCGA-A2-A04N-01A-11D-A10Y-09 0 0 0 1 2 #&gt; TCGA-A2-A0CP-01A-11W-A050-09 0 0 0 0 0 #&gt; TCGA-A2-A0EP-01A-52D-A22X-09 0 0 1 0 0 #&gt; TCGA-A2-A0EV-01A-11W-A050-09 0 0 1 0 0 We use notion left[ref&gt;mut]right to mark each component, e.g. C[T&gt;G]A means a base T with 5’ adjacent base C and 3’ adjacent base A is mutated to base G. 2.2.2 Other Situations Above we show the most common SBS classifications, there are other situations supported by sigminer, including other classifications for SBS records and other mutation types (DBS and ID). All situations about SBS, DBS and ID signatures are well documented in wiki of SigProfilerMatrixGenerator package. 2.2.2.1 Other SBS classifications After calling sig_tally(), the most used matrix is stored in nmf_matrix, and all matrices generated by sigminer are stored in all_matrices. str(mt_tally$all_matrices, max.level = 1) #&gt; List of 3 #&gt; $ SBS_6 : int [1:100, 1:6] 7 6 5 4 9 7 5 5 0 5 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_96 : int [1:100, 1:96] 0 0 0 0 0 0 1 2 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_1536: int [1:100, 1:1536] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 If you add the strand classification, all matrices can be generated by sigminer will return. mt_tally2 &lt;- sig_tally( brca, ref_genome = &quot;BSgenome.Hsapiens.UCSC.hg19&quot;, useSyn = TRUE, add_trans_bias = TRUE ) #&gt; [36mℹ[39m [2020-10-09 00:02:16]: Started. #&gt; [32m✓[39m [2020-10-09 00:02:16]: Reference genome loaded. #&gt; [32m✓[39m [2020-10-09 00:02:16]: Variants from MAF object queried. #&gt; [32m✓[39m [2020-10-09 00:02:16]: Chromosome names checked. #&gt; [32m✓[39m [2020-10-09 00:02:16]: Sex chromosomes properly handled. #&gt; [32m✓[39m [2020-10-09 00:02:16]: Only variants located in standard chromosomes (1:22, X, Y, M/MT) are kept. #&gt; [32m✓[39m [2020-10-09 00:02:16]: Variant start and end position checked. #&gt; [32m✓[39m [2020-10-09 00:02:16]: Variant data for matrix generation preprocessed. #&gt; [36mℹ[39m [2020-10-09 00:02:16]: SBS matrix generation - start. #&gt; [36mℹ[39m [2020-10-09 00:02:16]: Extracting 5&#39; and 3&#39; adjacent bases. #&gt; [36mℹ[39m [2020-10-09 00:02:16]: Extracting +/- 20bp around mutated bases for background C&gt;T estimation. #&gt; [36mℹ[39m [2020-10-09 00:02:17]: Estimating APOBEC enrichment scores. #&gt; [36mℹ[39m [2020-10-09 00:02:17]: Performing one-way Fisher&#39;s test for APOBEC enrichment. #&gt; [32m✓[39m [2020-10-09 00:02:17]: APOBEC related mutations are enriched in 28% of samples (APOBEC enrichment score &gt; 2; 28 of 100 samples) #&gt; [36mℹ[39m [2020-10-09 00:02:17]: Creating SBS sample-by-component matrices. #&gt; [32m✓[39m [2020-10-09 00:02:17]: SBS-6 matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:17]: SBS-96 matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:17]: SBS-1536 matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:17]: SBS-24 (6x4) matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:17]: SBS-384 (96x4) matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:17]: SBS-6144 (1536x4) matrix created. #&gt; [36mℹ[39m [2020-10-09 00:02:17]: Return SBS-384 as major matrix. #&gt; [32m✓[39m [2020-10-09 00:02:17]: Done. #&gt; [36mℹ[39m [2020-10-09 00:02:17]: 1.793 secs elapsed. str(mt_tally2$all_matrices, max.level = 1) #&gt; List of 6 #&gt; $ SBS_6 : int [1:100, 1:6] 7 6 5 4 9 7 5 5 0 5 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_24 : int [1:100, 1:24] 6 3 3 2 6 4 1 2 0 3 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_96 : int [1:100, 1:96] 0 0 0 0 0 0 1 2 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_384 : int [1:100, 1:384] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_1536: int [1:100, 1:1536] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_6144: int [1:100, 1:6144] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 2.2.2.2 DBS and ID components If you want to generate DBS or ID matrices, just modify the mode option. mt_tally_DBS &lt;- sig_tally( brca, ref_genome = &quot;BSgenome.Hsapiens.UCSC.hg19&quot;, useSyn = TRUE, mode = &quot;DBS&quot;, add_trans_bias = TRUE ) #&gt; [36mℹ[39m [2020-10-09 00:02:18]: Started. #&gt; [32m✓[39m [2020-10-09 00:02:18]: Reference genome loaded. #&gt; [32m✓[39m [2020-10-09 00:02:18]: Variants from MAF object queried. #&gt; [32m✓[39m [2020-10-09 00:02:18]: Chromosome names checked. #&gt; [32m✓[39m [2020-10-09 00:02:18]: Sex chromosomes properly handled. #&gt; [32m✓[39m [2020-10-09 00:02:18]: Only variants located in standard chromosomes (1:22, X, Y, M/MT) are kept. #&gt; [32m✓[39m [2020-10-09 00:02:18]: Variant start and end position checked. #&gt; [32m✓[39m [2020-10-09 00:02:18]: Variant data for matrix generation preprocessed. #&gt; [36mℹ[39m [2020-10-09 00:02:18]: DBS matrix generation - start. #&gt; [36mℹ[39m [2020-10-09 00:02:18]: Searching DBS records... #&gt; [32m✓[39m [2020-10-09 00:02:19]: Done. #&gt; [32m✓[39m [2020-10-09 00:02:19]: Reference sequences queried from genome. #&gt; [32m✓[39m [2020-10-09 00:02:19]: DBS-78 matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:19]: DBS-1248 matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:19]: DBS-186 matrix created. #&gt; [36mℹ[39m [2020-10-09 00:02:20]: Return DBS-186 as major matrix. #&gt; [32m✓[39m [2020-10-09 00:02:20]: Done. #&gt; [36mℹ[39m [2020-10-09 00:02:20]: 2.07 secs elapsed. str(mt_tally_DBS$all_matrices, max.level = 1) #&gt; List of 3 #&gt; $ DBS_78 : int [1:100, 1:78] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ DBS_186 : int [1:100, 1:186] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ DBS_1248: int [1:100, 1:1248] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 Program will stop if no records to analyze. Let’s see ID records. mt_tally_ID &lt;- sig_tally( brca, ref_genome = &quot;BSgenome.Hsapiens.UCSC.hg19&quot;, useSyn = TRUE, mode = &quot;ID&quot;, add_trans_bias = TRUE ) #&gt; [36mℹ[39m [2020-10-09 00:02:20]: Started. #&gt; [32m✓[39m [2020-10-09 00:02:20]: Reference genome loaded. #&gt; [32m✓[39m [2020-10-09 00:02:20]: Variants from MAF object queried. #&gt; [32m✓[39m [2020-10-09 00:02:20]: Chromosome names checked. #&gt; [32m✓[39m [2020-10-09 00:02:20]: Sex chromosomes properly handled. #&gt; [32m✓[39m [2020-10-09 00:02:20]: Only variants located in standard chromosomes (1:22, X, Y, M/MT) are kept. #&gt; [32m✓[39m [2020-10-09 00:02:20]: Variant start and end position checked. #&gt; [32m✓[39m [2020-10-09 00:02:20]: Variant data for matrix generation preprocessed. #&gt; [36mℹ[39m [2020-10-09 00:02:20]: INDEL matrix generation - start. #&gt; [32m✓[39m [2020-10-09 00:02:21]: Reference sequences queried from genome. #&gt; [32m✓[39m [2020-10-09 00:02:21]: INDEL length extracted. #&gt; [32m✓[39m [2020-10-09 00:02:21]: Adjacent copies counted. #&gt; [32m✓[39m [2020-10-09 00:02:45]: Microhomology size calculated. #&gt; [32m✓[39m [2020-10-09 00:02:45]: INDEL records classified into different components (types). #&gt; [32m✓[39m [2020-10-09 00:02:45]: ID-28 matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:45]: ID-83 matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:45]: ID-415 matrix created. #&gt; [36mℹ[39m [2020-10-09 00:02:45]: Return ID-415 as major matrix. #&gt; [32m✓[39m [2020-10-09 00:02:45]: Done. #&gt; [36mℹ[39m [2020-10-09 00:02:45]: 25.428 secs elapsed. str(mt_tally_ID$all_matrices, max.level = 1) #&gt; List of 3 #&gt; $ ID_28 : int [1:100, 1:28] 0 1 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ ID_83 : int [1:100, 1:83] 0 1 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ ID_415:&#39;data.frame&#39;: 100 obs. of 415 variables: 2.2.2.3 Take togother If you want to get all matrices for SBS, DBS and ID at the same time, you don’t need to write a for loop or type three times to do this. Just set mode='ALL', sigminer will do it for you! mt_tally_all &lt;- sig_tally( brca, ref_genome = &quot;BSgenome.Hsapiens.UCSC.hg19&quot;, useSyn = TRUE, mode = &quot;ALL&quot;, add_trans_bias = TRUE ) #&gt; [36mℹ[39m [2020-10-09 00:02:45]: Started. #&gt; [32m✓[39m [2020-10-09 00:02:45]: Reference genome loaded. #&gt; [32m✓[39m [2020-10-09 00:02:45]: Variants from MAF object queried. #&gt; [32m✓[39m [2020-10-09 00:02:45]: Chromosome names checked. #&gt; [32m✓[39m [2020-10-09 00:02:45]: Sex chromosomes properly handled. #&gt; [32m✓[39m [2020-10-09 00:02:45]: Only variants located in standard chromosomes (1:22, X, Y, M/MT) are kept. #&gt; [32m✓[39m [2020-10-09 00:02:45]: Variant start and end position checked. #&gt; [32m✓[39m [2020-10-09 00:02:45]: Variant data for matrix generation preprocessed. #&gt; [36mℹ[39m [2020-10-09 00:02:45]: All types of matrices generation - start. #&gt; [36mℹ[39m [2020-10-09 00:02:45]: SBS matrix generation - start. #&gt; [36mℹ[39m [2020-10-09 00:02:45]: Extracting 5&#39; and 3&#39; adjacent bases. #&gt; [36mℹ[39m [2020-10-09 00:02:47]: Extracting +/- 20bp around mutated bases for background C&gt;T estimation. #&gt; [36mℹ[39m [2020-10-09 00:02:47]: Estimating APOBEC enrichment scores. #&gt; [36mℹ[39m [2020-10-09 00:02:47]: Performing one-way Fisher&#39;s test for APOBEC enrichment. #&gt; [32m✓[39m [2020-10-09 00:02:48]: APOBEC related mutations are enriched in 28% of samples (APOBEC enrichment score &gt; 2; 28 of 100 samples) #&gt; [36mℹ[39m [2020-10-09 00:02:48]: Creating SBS sample-by-component matrices. #&gt; [32m✓[39m [2020-10-09 00:02:48]: SBS-6 matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:48]: SBS-96 matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:48]: SBS-1536 matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:48]: SBS-24 (6x4) matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:48]: SBS-384 (96x4) matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:49]: SBS-6144 (1536x4) matrix created. #&gt; [36mℹ[39m [2020-10-09 00:02:49]: Return SBS-384 as major matrix. #&gt; [36mℹ[39m [2020-10-09 00:02:49]: DBS matrix generation - start. #&gt; [36mℹ[39m [2020-10-09 00:02:49]: Searching DBS records... #&gt; [32m✓[39m [2020-10-09 00:02:49]: Done. #&gt; [32m✓[39m [2020-10-09 00:02:50]: Reference sequences queried from genome. #&gt; [32m✓[39m [2020-10-09 00:02:50]: DBS-78 matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:50]: DBS-1248 matrix created. #&gt; [32m✓[39m [2020-10-09 00:02:50]: DBS-186 matrix created. #&gt; [36mℹ[39m [2020-10-09 00:02:50]: Return DBS-186 as major matrix. #&gt; [36mℹ[39m [2020-10-09 00:02:50]: INDEL matrix generation - start. #&gt; [32m✓[39m [2020-10-09 00:02:51]: Reference sequences queried from genome. #&gt; [32m✓[39m [2020-10-09 00:02:52]: INDEL length extracted. #&gt; [32m✓[39m [2020-10-09 00:02:52]: Adjacent copies counted. #&gt; [32m✓[39m [2020-10-09 00:03:15]: Microhomology size calculated. #&gt; [32m✓[39m [2020-10-09 00:03:15]: INDEL records classified into different components (types). #&gt; [32m✓[39m [2020-10-09 00:03:15]: ID-28 matrix created. #&gt; [32m✓[39m [2020-10-09 00:03:15]: ID-83 matrix created. #&gt; [32m✓[39m [2020-10-09 00:03:15]: ID-415 matrix created. #&gt; [36mℹ[39m [2020-10-09 00:03:15]: Return ID-415 as major matrix. #&gt; [36mℹ[39m [2020-10-09 00:03:15]: All types of matrices generation (APOBEC scores included) - end. #&gt; [32m✓[39m [2020-10-09 00:03:15]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:15]: 29.808 secs elapsed. str(mt_tally_all, max.level = 1) #&gt; List of 13 #&gt; $ SBS_6 : int [1:100, 1:6] 7 6 5 4 9 7 5 5 0 5 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_24 : int [1:100, 1:24] 6 3 3 2 6 4 1 2 0 3 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_96 : int [1:100, 1:96] 0 0 0 0 0 0 1 2 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_384 : int [1:100, 1:384] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_1536 : int [1:100, 1:1536] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ SBS_6144 : int [1:100, 1:6144] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ DBS_78 : int [1:100, 1:78] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ DBS_186 : int [1:100, 1:186] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ DBS_1248 : int [1:100, 1:1248] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ ID_28 : int [1:100, 1:28] 0 1 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ ID_83 : int [1:100, 1:83] 0 1 0 0 0 0 0 0 0 0 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; $ ID_415 :&#39;data.frame&#39;: 100 obs. of 415 variables: #&gt; $ APOBEC_scores:Classes &#39;data.table&#39; and &#39;data.frame&#39;: 100 obs. of 44 variables: #&gt; ..- attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; #&gt; ..- attr(*, &quot;index&quot;)= int(0) #&gt; .. ..- attr(*, &quot;__APOBEC_Enriched&quot;)= int [1:100] 17 21 23 24 25 26 27 28 30 32 ... Please note, in this case, just a list containing matrices will return. 2.3 Extract Signatures There are two different approaches can be used to implement signature extraction. Semi-automatic way. Firstly estimate signature number and then extract signatures. This is the basic usage of NMF package (Gaujoux and Seoighe 2010). Run multiple times of NMF in a range of signature number firstly and compute some measures to let you consider which signature number is suitable and then extract specified number of signatures again with NMF package. Automatic way. This includes multiple implementations, and will be described in corresponding part. 2.3.1 Method 1: Estimate Signature Number To estimate signature number, we firstly run NMF for multiple times and calculate some measures from the results, then select the best signature number based on the measure vs. signature number plot. This is done by sig_estimate() function. Let’s try signature number 2-6. For simplicity, we just run NMF twice for each signature number. We use 4 cores to speed up the computation. library(NMF) mt_est &lt;- sig_estimate(mt_tally$nmf_matrix, range = 2:6, nrun = 10, # increase this value if you wana a more stable estimation use_random = FALSE, # if TRUE, add results from randomized input cores = 4, pConstant = 1e-13, verbose = TRUE ) pConstant option is set to avoid errors raised by NMF package. We can show signature number survey for different measures by show_sig_number_survey2(). ## You can also select the measures to show ## by &#39;what&#39; option show_sig_number_survey2(mt_est$survey) &gt; For the details of all the measures above, please read Gaujoux and Seoighe (2010) and vignette of R package NMF. The measures either provide stability (cophenetic) or how well can be reconstructed (rss). Typically, measure cophenetic is used for determining the signature number. We can easily generate an elbow plot with function show_sig_number_survey(). show_sig_number_survey(mt_est$survey, right_y = NULL) &gt; The most common approach is to use the cophenetic correlation coefficient. Brunet et al. suggested choosing the smallest value of r for which this coefficient starts decreasing. (Gaujoux and Seoighe 2010) Cophenetic value (range from 0-1) indicates the robustness of consensus matrix clustering. In this situation, 3 is good. However, we can found that the cophenetic values are all &gt;=0.9 from 2 to 5. So the more suitable way is considering both stability and reconstruction error at the same time, it can be easily done by show_sig_number_survey(). show_sig_number_survey(mt_est$survey) &gt; This function is very flexible, you can pick up any measure to the left/right axis. However, the default setting is the most recommended way. We can see that we get a minimal RSS in signature number, and when this value goes from 5 to 6, the RSS increase! So we should not choose signature number more than 5 here because 6 is overfitting. NOTE: There are no gold standard to determine the signature number. Sometimes, you should consider multiple measures. Remember, the most important thing is that you should have a good biological explanation for each signature. The best solution in study may not be the best solution in math. 2.3.2 Method 1: Extract Signatures After selecting a suitable signature number, now you can extract signatures. In general, use 30~50 NMF runs will get a robust result. Here we extract 5 signatures. mt_sig &lt;- sig_extract(mt_tally$nmf_matrix, n_sig = 5, nrun = 30, cores = 4, pConstant = 1e-13 ) 2.3.3 Method 2: Auto-extraction If you have no idea to select an optimal signature number from procedures above, you can try auto-extraction approaches provided by sigminer. The latest version of sigminer provides two ways to auto-extract mutation signatures. Auto-extract signatures by automatic relevance determination technique in non-negative matrix factorization (Tan and Févotte 2012), the code is implemented by SignatureAnalyzer (Kim et al. 2016) and exported to sigminer. This approach is known as bayesian NMF. Auto-extract signatures by SigProfiler, the gold-standard tool used for identifying signatures cataloged in COSMIC database. The technical details please read Alexandrov et al. (2020). 2.3.3.1 Method 2: bayesian NMF In this approach, you need to set a maximum signature number (default is 25) and run times to get the result. 10 for nrun here is okay, and more than 100 is not recommended. The bayesian NMF will starts from a larger signature number and reduce it to a proper signature number to maximize posterior probability. mt_sig2 &lt;- sig_auto_extract(mt_tally$nmf_matrix, K0 = 10, nrun = 10, strategy = &quot;stable&quot; ) Here the program uses ‘robust’ strategy to return the result (see strategy option). It means that if you run 10 times and 6 of them return 4 signatures, then the optimal result with 4 signatures will be returned. The info of each run can be given as: knitr::kable(mt_sig2$Raw$summary_run) Run K posterior file 3 3 -1497.670 /var/folders/bj/nw1w4g1j37ddpgb6zmh3sfh80000gn/T//RtmpqXIwLJ/BayesNMF.3.rds 9 3 -1497.752 /var/folders/bj/nw1w4g1j37ddpgb6zmh3sfh80000gn/T//RtmpqXIwLJ/BayesNMF.9.rds 2 3 -1498.428 /var/folders/bj/nw1w4g1j37ddpgb6zmh3sfh80000gn/T//RtmpqXIwLJ/BayesNMF.2.rds 10 3 -1498.528 /var/folders/bj/nw1w4g1j37ddpgb6zmh3sfh80000gn/T//RtmpqXIwLJ/BayesNMF.10.rds 6 3 -1498.596 /var/folders/bj/nw1w4g1j37ddpgb6zmh3sfh80000gn/T//RtmpqXIwLJ/BayesNMF.6.rds 1 3 -1498.830 /var/folders/bj/nw1w4g1j37ddpgb6zmh3sfh80000gn/T//RtmpqXIwLJ/BayesNMF.1.rds 7 3 -1498.890 /var/folders/bj/nw1w4g1j37ddpgb6zmh3sfh80000gn/T//RtmpqXIwLJ/BayesNMF.7.rds 4 3 -1499.207 /var/folders/bj/nw1w4g1j37ddpgb6zmh3sfh80000gn/T//RtmpqXIwLJ/BayesNMF.4.rds 8 3 -1524.316 /var/folders/bj/nw1w4g1j37ddpgb6zmh3sfh80000gn/T//RtmpqXIwLJ/BayesNMF.8.rds 5 4 -1617.962 /var/folders/bj/nw1w4g1j37ddpgb6zmh3sfh80000gn/T//RtmpqXIwLJ/BayesNMF.5.rds The mt_sig2 has similar structure as mut_sig. 2.3.3.2 Method 2: SigProfiler Sigminer provides two functions sigprofiler_extract() and sigprofiler_import() to install, use SigProfiler and import SigProfiler results into R as a Signature object like other extraction methods mentioned above. An (not running) example is given below (see ?sigprofiler for more info). load(system.file(&quot;extdata&quot;, &quot;toy_copynumber_tally_M.RData&quot;, package = &quot;sigminer&quot;, mustWork = TRUE )) reticulate::conda_list() sigprofiler_extract(cn_tally_M$nmf_matrix, &quot;~/test/test_sigminer&quot;, use_conda = TRUE ) sigprofiler_extract(cn_tally_M$nmf_matrix, &quot;~/test/test_sigminer&quot;, use_conda = FALSE, py_path = &quot;/Users/wsx/anaconda3/bin/python&quot; ) 2.4 Match Signatures After extracting signatures, we need to know their etiologies. This can be done by comparing the identified signatures and reference signatures from COSMIC database. sim &lt;- get_sig_similarity(mt_sig2) #&gt; -Comparing against COSMIC signatures #&gt; ------------------------------------ #&gt; --Found Sig1 most similar to COSMIC_3 #&gt; Aetiology: defects in DNA-DSB repair by HR [similarity: 0.82] #&gt; --Found Sig2 most similar to COSMIC_1 #&gt; Aetiology: spontaneous deamination of 5-methylcytosine [similarity: 0.942] #&gt; --Found Sig3 most similar to COSMIC_2 #&gt; Aetiology: APOBEC Cytidine Deaminase (C&gt;T) [similarity: 0.84] #&gt; ------------------------------------ #&gt; Return result invisiblely. The result object sim is a list. str(sim) #&gt; List of 4 #&gt; $ similarity : num [1:3, 1:30] 0.82 0.264 0.373 0.581 0.942 0.165 0.085 0.256 0.84 0.714 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; .. ..$ : chr [1:3] &quot;Sig1&quot; &quot;Sig2&quot; &quot;Sig3&quot; #&gt; .. ..$ : chr [1:30] &quot;COSMIC_3&quot; &quot;COSMIC_1&quot; &quot;COSMIC_2&quot; &quot;COSMIC_4&quot; ... #&gt; $ aetiology_db:List of 1 #&gt; ..$ : chr [1:30] &quot;spontaneous deamination of 5-methylcytosine&quot; &quot;APOBEC Cytidine Deaminase (C&gt;T)&quot; &quot;defects in DNA-DSB repair by HR&quot; &quot;exposure to tobacco (smoking) mutagens&quot; ... #&gt; $ best_match :List of 3 #&gt; ..$ Sig1:List of 2 #&gt; .. ..$ aetiology : chr &quot;defects in DNA-DSB repair by HR&quot; #&gt; .. ..$ best_match: chr &quot;Best match: COSMIC_3 [similarity: 0.82]&quot; #&gt; ..$ Sig2:List of 2 #&gt; .. ..$ aetiology : chr &quot;spontaneous deamination of 5-methylcytosine&quot; #&gt; .. ..$ best_match: chr &quot;Best match: COSMIC_1 [similarity: 0.942]&quot; #&gt; ..$ Sig3:List of 2 #&gt; .. ..$ aetiology : chr &quot;APOBEC Cytidine Deaminase (C&gt;T)&quot; #&gt; .. ..$ best_match: chr &quot;Best match: COSMIC_2 [similarity: 0.84]&quot; #&gt; $ rss : num [1:3, 1:30] 0.04166 0.00711 0.14698 0.2492 0.24257 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; .. ..$ : chr [1:3] &quot;Sig1&quot; &quot;Sig2&quot; &quot;Sig3&quot; #&gt; .. ..$ : chr [1:30] &quot;COSMIC_1&quot; &quot;COSMIC_2&quot; &quot;COSMIC_3&quot; &quot;COSMIC_4&quot; ... #&gt; - attr(*, &quot;class&quot;)= chr [1:2] &quot;similarity&quot; &quot;list&quot; From the result we can see that three signatures are properly matched to COSMIC reference signatures. If you find unknown signatures in your study, you should explore the etiologies by other analyses and even experiments. The similarity matrix can be plotted. pheatmap::pheatmap(sim$similarity) You can also try the COSMIC signature database V3 with: sim_v3 &lt;- get_sig_similarity(mt_sig2, sig_db = &quot;SBS&quot;) #&gt; -Comparing against COSMIC signatures #&gt; ------------------------------------ #&gt; --Found Sig1 most similar to SBS3 #&gt; Aetiology: Defects in DNA-DSB repair by HR [similarity: 0.821] #&gt; --Found Sig2 most similar to SBS1 #&gt; Aetiology: spontaneous or enzymatic deamination of 5-methylcytosine [similarity: 0.876] #&gt; --Found Sig3 most similar to SBS2 #&gt; Aetiology: APOBEC Cytidine Deaminase (C&gt;T) [similarity: 0.748] #&gt; ------------------------------------ #&gt; Return result invisiblely. 2.5 Operate Signature The result of sig_extract() or sig_auto_extract() is a list with Signature class. You can use $ or use operation function to obtain the data stored in it. To get the signature matrix: # Or mt_sig2$Signature sig_signature(mt_sig2)[1:5, ] #&gt; Sig1 Sig2 Sig3 #&gt; A[T&gt;C]A 0.008982565 0.012815512 0.0027641452 #&gt; C[T&gt;C]A 0.006295256 0.006378091 0.0008926155 #&gt; G[T&gt;C]A 0.013961272 0.002795088 0.0010525932 #&gt; T[T&gt;C]A 0.004574805 0.004748670 0.0012218410 #&gt; A[C&gt;T]A 0.004672896 0.018070168 0.0063343170 To get signature exposure matrix: # Or mt_sig$Exposure sig_exposure(mt_sig2)[, 1:5] #&gt; TCGA-A1-A0SH-01A-11D-A099-09 TCGA-A2-A04N-01A-11D-A10Y-09 TCGA-A2-A0CP-01A-11W-A050-09 #&gt; Sig1 32.15907 15.839732 22.947414 #&gt; Sig2 16.59291 32.478516 22.476482 #&gt; Sig3 87.05947 3.137845 4.608987 #&gt; TCGA-A2-A0EP-01A-52D-A22X-09 TCGA-A2-A0EV-01A-11W-A050-09 #&gt; Sig1 14.4657384 35.25795 #&gt; Sig2 0.4796753 25.49099 #&gt; Sig3 6.9200983 17.57883 get_sig_exposure() may be more useful, it can be used to return a data.frame and set an exposure threshold. get_sig_exposure(mt_sig2) #&gt; sample Sig1 Sig2 Sig3 #&gt; 1: TCGA-A1-A0SH-01A-11D-A099-09 3.215907e+01 1.659291e+01 8.705947e+01 #&gt; 2: TCGA-A2-A04N-01A-11D-A10Y-09 1.583973e+01 3.247852e+01 3.137845e+00 #&gt; 3: TCGA-A2-A0CP-01A-11W-A050-09 2.294741e+01 2.247648e+01 4.608987e+00 #&gt; 4: TCGA-A2-A0EP-01A-52D-A22X-09 1.446574e+01 4.796753e-01 6.920098e+00 #&gt; 5: TCGA-A2-A0EV-01A-11W-A050-09 3.525795e+01 2.549099e+01 1.757883e+01 #&gt; 6: TCGA-A2-A0SX-01A-12D-A099-09 1.890198e+01 1.190887e+01 9.765504e+00 #&gt; 7: TCGA-A2-A0T7-01A-21D-A099-09 7.058436e+00 2.206062e+01 2.063678e-01 #&gt; 8: TCGA-A2-A0YF-01A-21D-A10G-09 1.308864e+01 2.872085e+01 3.276018e-121 #&gt; 9: TCGA-A2-A25F-01A-11D-A167-09 8.956460e+00 2.075076e-322 0.000000e+00 #&gt; 10: TCGA-A2-A3XW-01A-11D-A23C-09 1.022872e+01 7.998442e+00 6.307634e-01 #&gt; 11: TCGA-A2-A4S1-01A-21D-A25Q-09 7.051307e+01 2.151502e+01 4.647996e+00 #&gt; 12: TCGA-A7-A0D9-01A-31W-A071-09 2.911793e+01 1.460116e+01 1.642104e+01 #&gt; 13: TCGA-A7-A13F-01A-11D-A12Q-09 1.445889e-99 7.200445e+01 1.005387e+01 #&gt; 14: TCGA-A7-A5ZV-01A-11D-A28B-09 1.744084e+02 3.859699e+01 3.691587e+01 #&gt; 15: TCGA-A8-A06P-01A-11W-A019-09 2.224565e+01 1.850442e+01 3.520406e+00 #&gt; 16: TCGA-A8-A076-01A-21W-A019-09 3.334543e+01 4.665212e+01 1.243664e+01 #&gt; 17: TCGA-A8-A07W-01A-11W-A019-09 1.027996e+02 4.510342e+01 2.145630e+01 #&gt; 18: TCGA-A8-A084-01A-21W-A019-09 1.875160e+01 3.524792e+01 2.879974e+01 #&gt; 19: TCGA-A8-A08S-01A-11W-A050-09 1.735008e+01 4.659754e+01 1.427450e-05 #&gt; 20: TCGA-A8-A09G-01A-21W-A019-09 2.720241e-49 1.598340e+01 3.015537e+02 #&gt; 21: TCGA-A8-A0A4-01A-11W-A019-09 1.301530e+01 2.414905e+01 9.673844e-01 #&gt; 22: TCGA-A8-A0AB-01A-11W-A050-09 2.224326e+01 1.070162e+01 4.625000e+00 #&gt; 23: TCGA-AC-A2B8-01A-11D-A17D-09 4.581254e-74 2.077930e+01 1.039934e+02 #&gt; 24: TCGA-AC-A2FO-01A-11D-A17W-09 8.224234e+00 6.022061e+00 1.457732e+01 #&gt; 25: TCGA-AC-A3YI-01A-21D-A23C-09 1.181688e+01 8.021717e+00 4.392543e-188 #&gt; 26: TCGA-AC-A8OS-01A-12D-A41F-09 3.481344e+01 2.558226e+01 1.892168e+01 #&gt; 27: TCGA-AN-A0FK-01A-11W-A050-09 2.057755e-97 5.410512e+01 6.931546e-201 #&gt; 28: TCGA-AN-A0FT-01A-11W-A050-09 2.445782e+01 6.250409e+01 3.692872e+01 #&gt; 29: TCGA-AN-A0XO-01A-11D-A10G-09 1.852324e+01 1.228874e+01 1.174155e+01 #&gt; 30: TCGA-AO-A1KS-01A-11D-A13L-09 4.164234e+00 3.175461e+01 1.956542e+01 #&gt; 31: TCGA-AQ-A54O-01A-11D-A25Q-09 3.055399e-28 2.459937e+01 5.953473e-01 #&gt; 32: TCGA-AQ-A7U7-01A-22D-A351-09 1.358585e+01 1.441648e+01 7.330881e+01 #&gt; 33: TCGA-AR-A0TP-01A-11D-A099-09 5.768672e+01 6.630986e+00 5.803076e+00 #&gt; 34: TCGA-AR-A0U3-01A-11D-A10G-09 1.733324e+01 2.281135e+01 3.013800e-322 #&gt; 35: TCGA-AR-A1AH-01A-11D-A12B-09 9.496609e+01 1.443596e+01 8.395297e+00 #&gt; 36: TCGA-AR-A1AJ-01A-21D-A12Q-09 7.534377e+00 2.369358e+01 2.277121e+01 #&gt; 37: TCGA-AR-A1AN-01A-11D-A12Q-09 6.529774e+00 2.102345e+01 5.820990e+00 #&gt; 38: TCGA-AR-A24N-01A-11D-A167-09 2.004502e+01 2.261256e+01 4.435549e+00 #&gt; 39: TCGA-AR-A252-01A-11D-A167-09 6.130705e+00 1.263644e+01 3.556170e-312 #&gt; 40: TCGA-AR-A2LL-01A-11D-A17W-09 1.503319e+01 2.218907e+01 8.682292e-233 #&gt; 41: TCGA-AR-A2LO-01A-31D-A18P-09 1.413060e+01 2.481548e+00 3.266687e+00 #&gt; 42: TCGA-B6-A0IE-01A-11W-A050-09 2.018322e+01 1.947366e+01 2.614518e+00 #&gt; 43: TCGA-B6-A0IM-01A-11W-A050-09 2.162813e+01 1.865495e+01 3.521674e-57 #&gt; 44: TCGA-B6-A0IP-01A-11D-A045-09 1.442865e+01 3.592925e+01 8.112508e-01 #&gt; 45: TCGA-B6-A0RV-01A-11D-A099-09 1.560069e-177 1.750629e+01 4.905081e+01 #&gt; 46: TCGA-B6-A0WZ-01A-11D-A10G-09 6.958489e+00 6.417496e+00 8.073838e+01 #&gt; 47: TCGA-B6-A0X1-01A-11D-A10G-09 4.814384e+01 2.024595e+01 2.160594e+01 #&gt; 48: TCGA-B6-A1KC-01B-11D-A159-09 1.272953e+01 2.179920e+01 7.508081e-01 #&gt; 49: TCGA-B6-A401-01A-11D-A23C-09 1.081423e+01 1.941480e+01 2.059546e-01 #&gt; 50: TCGA-B6-A40C-01A-11D-A23C-09 1.830003e+01 3.154423e+01 2.647047e+00 #&gt; 51: TCGA-BH-A0AV-01A-31D-A10Y-09 6.587096e+01 2.929251e+00 1.572687e+01 #&gt; 52: TCGA-BH-A0BT-01A-11D-A12Q-09 6.568456e+00 3.775611e+01 2.752085e+00 #&gt; 53: TCGA-BH-A0DL-01A-11D-A10Y-09 2.910845e+01 6.775503e+01 2.920173e+01 #&gt; 54: TCGA-BH-A0DO-01B-11D-A12B-09 1.010194e+01 1.427067e+01 5.289001e+00 #&gt; 55: TCGA-BH-A0DT-01A-21D-A12B-09 3.335864e+00 1.048536e+01 2.024691e+00 #&gt; 56: TCGA-BH-A0GY-01A-11W-A071-09 1.586565e+01 2.609193e+01 7.451332e-171 #&gt; 57: TCGA-BH-A0H6-01A-21W-A071-09 1.075555e+01 1.584751e+01 6.033999e-182 #&gt; 58: TCGA-BH-A18K-01A-11D-A12B-09 2.201843e+01 1.341495e+01 3.649113e+01 #&gt; 59: TCGA-BH-A1FU-01A-11D-A14G-09 6.503440e+01 2.615015e+01 2.435476e+01 #&gt; 60: TCGA-BH-A202-01A-11D-A14K-09 9.499339e+00 1.718580e+01 8.725869e-01 #&gt; 61: TCGA-BH-A5IZ-01A-11D-A27P-09 1.272274e+02 1.895424e+01 3.599703e+01 #&gt; 62: TCGA-BH-A6R8-01A-21D-A33E-09 1.333218e+01 2.247599e+01 5.410627e+00 #&gt; 63: TCGA-BH-A8G0-01A-11D-A351-09 5.329473e-61 2.044391e+01 0.000000e+00 #&gt; 64: TCGA-C8-A131-01A-11D-A10Y-09 2.892229e+01 4.000734e+01 4.478124e+00 #&gt; 65: TCGA-D8-A147-01A-11D-A10Y-09 1.170598e+02 3.708374e+00 7.345449e+01 #&gt; 66: TCGA-D8-A1JG-01B-11D-A13L-09 8.510523e+01 6.270187e+01 2.084379e+01 #&gt; 67: TCGA-D8-A1JH-01A-11D-A188-09 1.123474e+01 1.153185e+01 9.875530e-01 #&gt; 68: TCGA-D8-A1JJ-01A-31D-A14K-09 1.266815e+01 3.477698e+01 5.170826e+01 #&gt; 69: TCGA-D8-A1JT-01A-31D-A13L-09 2.184767e+01 2.034265e+01 0.000000e+00 #&gt; 70: TCGA-D8-A1JU-01A-11D-A13L-09 9.975756e+00 9.782078e+00 6.083460e-02 #&gt; 71: TCGA-D8-A1X7-01A-11D-A14K-09 1.298671e+01 1.517123e+01 3.439192e+00 #&gt; 72: TCGA-D8-A1X8-01A-11D-A14K-09 1.460678e+01 1.557185e+01 2.380506e+00 #&gt; 73: TCGA-D8-A1XL-01A-11D-A14K-09 7.763404e+01 2.055349e+01 7.951866e+00 #&gt; 74: TCGA-D8-A27V-01A-12D-A17D-09 3.443723e-45 3.089542e+01 1.885408e+02 #&gt; 75: TCGA-E2-A108-01A-13D-A10M-09 3.697383e+01 1.205971e+01 1.342740e+02 #&gt; 76: TCGA-E2-A10F-01A-11D-A10M-09 1.114497e-181 2.407471e+01 5.142756e+00 #&gt; 77: TCGA-E2-A14T-01A-11D-A10Y-09 1.818548e+01 1.757560e+01 7.623413e+00 #&gt; 78: TCGA-E2-A152-01A-11D-A12B-09 3.004158e-05 1.904189e+01 1.453822e+02 #&gt; 79: TCGA-E2-A15D-01A-11D-A10Y-09 1.239561e+01 2.367115e+01 1.043255e-01 #&gt; 80: TCGA-E2-A15L-01A-11D-A12B-09 8.316254e-163 3.696156e+01 7.198468e+00 #&gt; 81: TCGA-E2-A1BD-01A-11D-A12Q-09 1.325256e+01 2.837122e+01 2.099082e-01 #&gt; 82: TCGA-E2-A1IH-01A-11D-A188-09 1.809753e+01 2.554536e+01 4.060186e+01 #&gt; 83: TCGA-E2-A1II-01A-11D-A142-09 3.354037e+01 8.480730e-01 3.013800e-322 #&gt; 84: TCGA-E2-A1IJ-01A-11D-A142-09 6.756677e+00 1.299390e+01 2.269978e-182 #&gt; 85: TCGA-E2-A1L6-01A-11D-A13L-09 3.756995e+00 2.424052e+01 2.129975e-01 #&gt; 86: TCGA-E2-A9RU-01A-11D-A41F-09 2.127087e+01 6.202103e+01 2.115210e+01 #&gt; 87: TCGA-E9-A1NE-01A-21D-A14K-09 5.089464e+01 3.340837e+00 6.326526e+00 #&gt; 88: TCGA-E9-A22A-01A-11D-A159-09 1.977296e+01 6.638223e+00 1.027258e+01 #&gt; 89: TCGA-E9-A22E-01A-11D-A159-09 9.379149e+01 8.398077e+00 4.506802e+01 #&gt; 90: TCGA-E9-A3QA-01A-61D-A228-09 3.295112e+01 3.947921e+00 2.814997e+01 #&gt; 91: TCGA-E9-A5FL-01A-11D-A27P-09 9.173188e+01 1.165295e+01 2.949295e+01 #&gt; 92: TCGA-EW-A1PA-01A-11D-A142-09 2.061895e+01 1.721686e+01 4.530208e+00 #&gt; 93: TCGA-EW-A1PH-01A-11D-A14K-09 2.609288e+01 3.002828e+01 8.280088e+00 #&gt; 94: TCGA-GM-A2DB-01A-31D-A19Y-09 8.511084e+01 2.993667e+01 1.374699e+01 #&gt; 95: TCGA-LD-A9QF-01A-32D-A41F-09 1.531207e+01 2.246112e+01 1.427438e+00 #&gt; 96: TCGA-LL-A5YP-01A-21D-A28B-09 7.894136e+01 6.635690e+00 2.079587e+01 #&gt; 97: TCGA-LL-A73Z-01A-11D-A32I-09 2.442986e+01 2.675728e+01 2.533581e+00 #&gt; 98: TCGA-OL-A5RY-01A-21D-A28B-09 7.440440e+00 7.048267e+00 1.414288e+00 #&gt; 99: TCGA-PE-A5DD-01A-12D-A27P-09 5.246539e+00 3.625459e+01 4.294177e+01 #&gt; 100: TCGA-S3-AA17-01A-11D-A41F-09 9.522553e+01 2.687635e+01 2.082856e+01 #&gt; sample Sig1 Sig2 Sig3 For plotting signature profile and exposure profile, please go to chapter 8. For optimizing signature exposure, please use sig_fit(). References "],
["cnsig.html", "Chapter 3 Copy Number Signature Identification 3.1 Introduction 3.2 Read Data 3.3 Tally Components 3.4 Extract Signatures", " Chapter 3 Copy Number Signature Identification 3.1 Introduction Unlike several mutation types presented in current COSMIC database for generating mutational signatures, it is hard to represent copy number features and generate the matrix for NMF decomposition. Macintyre et al. (2018) created a new method to generate the matrix for extracting signature by NMF algorithm. The steps are: derive 6 copy number features from absolute copy number profile apply mixture modeling to breakdown each feature distribution into mixtures of Gaussian or mixtures of Poisson distributions generate a sample-by-component matrix representing the sum of posterior probabilities of each copy-number event being assigned to each component. Based on previous work, our group devised a new method which discards the statistical modeling and create a fixed number of predefined components from 8 copy number features to generate the matrix as the input of NMF (Wang et al. 2020), it is easier to reproduce the result, apply to different cancer types and compare results. To test if the method would works, we applied it to prostate cancer and successfully identified 5 copy number signatures. Currently, there are few studies focus on copy number signatures and no reference signature database for matching and explaining the etiologies (The signatures presented in two papers above can be used as references). If you study them, you should do extra work to explore and validate them. Furthermore, the input absolute copy number data may be generated by different methods and platforms, it is normal that the contribution of some copy number feature components varies a little and result in relatively lower signature similarity when comparing different cohorts or different copy number profile generation methods. 3.2 Read Data The input requires absolute copy number profile with following information: Segment chromosome. Segment start. Segment end. Absolute copy number value for this segment: must be integer. Sample ID. The input data can be result from any software which provides information above. Useful softwares are listed below: ABSOLUTE. Sequenza FACETS PennCNV &amp; ASCAT CNVkit The import work is done by read_copynumber(), which supports data.frame or file, and even result directory from ABSOLUTE. Option sigminer.sex is used to control the processing of sex. If you don’t care the sex chromosomes (i.e. X and Y), you can ignore this setting after removing the X/Y segments, otherwise the summary in the result cn and tally process may be biased. ## Default is &quot;female&quot; ## You can ignore the setting if all samples are females ## But we recommend you set it options(sigminer.sex = &quot;male&quot;) ## For cohort contains both males and females, ## set a data.frame with two columns, i.e. ## options(sigminer.sex = sex_df), ## which ## sex_df = data.frame(sample = c(&quot;sample1&quot;, &quot;sample2&quot;, ## sex = &quot;female&quot;, &quot;male&quot;)) # Load toy dataset of absolute copynumber profile load(system.file(&quot;extdata&quot;, &quot;toy_segTab.RData&quot;, package = &quot;sigminer&quot;, mustWork = TRUE )) cn &lt;- read_copynumber(segTabs, seg_cols = c(&quot;chromosome&quot;, &quot;start&quot;, &quot;end&quot;, &quot;segVal&quot;), genome_build = &quot;hg19&quot;, complement = FALSE, verbose = TRUE ) #&gt; [36mℹ[39m [2020-10-09 00:03:18]: Started. #&gt; [36mℹ[39m [2020-10-09 00:03:18]: Genome build : hg19. #&gt; [36mℹ[39m [2020-10-09 00:03:18]: Genome measure: called. #&gt; [32m✓[39m [2020-10-09 00:03:18]: Chromosome size database for build obtained. #&gt; [36mℹ[39m [2020-10-09 00:03:18]: Reading input. #&gt; [32m✓[39m [2020-10-09 00:03:18]: A data frame as input detected. #&gt; [32m✓[39m [2020-10-09 00:03:18]: Column names checked. #&gt; [32m✓[39m [2020-10-09 00:03:18]: Column order set. #&gt; [32m✓[39m [2020-10-09 00:03:18]: Chromosomes unified. #&gt; [32m✓[39m [2020-10-09 00:03:18]: Data imported. #&gt; [36mℹ[39m [2020-10-09 00:03:18]: Segments info: #&gt; [36mℹ[39m [2020-10-09 00:03:18]: Keep - 467 #&gt; [36mℹ[39m [2020-10-09 00:03:18]: Drop - 0 #&gt; [32m✓[39m [2020-10-09 00:03:18]: Segments sorted. #&gt; [36mℹ[39m [2020-10-09 00:03:18]: Joining adjacent segments with same copy number value. Be patient... #&gt; [32m✓[39m [2020-10-09 00:03:18]: 400 segments left after joining. #&gt; [32m✓[39m [2020-10-09 00:03:18]: Segmental table cleaned. #&gt; [36mℹ[39m [2020-10-09 00:03:18]: Annotating. #&gt; [32m✓[39m [2020-10-09 00:03:18]: Annotation done. #&gt; [36mℹ[39m [2020-10-09 00:03:18]: Summarizing per sample. #&gt; [32m✓[39m [2020-10-09 00:03:18]: Summarized. #&gt; [36mℹ[39m [2020-10-09 00:03:18]: Generating CopyNumber object. #&gt; [32m✓[39m [2020-10-09 00:03:18]: Generated. #&gt; [36mℹ[39m [2020-10-09 00:03:18]: Validating object. #&gt; [32m✓[39m [2020-10-09 00:03:18]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:18]: 0.215 secs elapsed. cn #&gt; An object of class CopyNumber #&gt; ============================= #&gt; sample n_of_seg n_of_cnv n_of_amp n_of_del n_of_vchr cna_burden #&gt; 1: TCGA-DF-A2KN-01A-11D-A17U-01 33 6 5 1 4 0.000 #&gt; 2: TCGA-19-2621-01B-01D-0911-01 33 8 5 3 5 0.099 #&gt; 3: TCGA-B6-A0X5-01A-21D-A107-01 28 8 4 4 2 0.087 #&gt; 4: TCGA-A8-A07S-01A-11D-A036-01 38 11 2 9 4 0.112 #&gt; 5: TCGA-26-6174-01A-21D-1842-01 43 13 8 5 8 0.119 #&gt; 6: TCGA-CV-7432-01A-11D-2128-01 40 16 7 9 9 0.198 #&gt; 7: TCGA-06-0644-01A-02D-0310-01 46 19 5 14 8 0.165 #&gt; 8: TCGA-A5-A0G2-01A-11D-A042-01 39 21 5 16 10 0.393 #&gt; 9: TCGA-99-7458-01A-11D-2035-01 48 26 10 16 13 0.318 #&gt; 10: TCGA-05-4417-01A-22D-1854-01 52 37 33 4 17 0.654 Currently, you can refer to extract_facets_cnv() and extract_seqz_cnv() in https://github.com/ShixiangWang/prad_signature/blob/master/analysis/src/99-functions.R to see how to get tidy data from a result directory of FACETS or Sequenza. 3.3 Tally Components Currently, there are two methods for generating sample-by-component matrix, i.e. “W” or “M”. Option sigminer.copynumber.max is used to control the processing of max copy number values. Run ?sig_tally to see more. ## Even you set max_copynumber = 20 in read_copynumber(), ## the segmental copy number may be greater than 20 ## because for male samples, the X/Y segmental copy number ## values will be doubled in tally process. ## This setting will make copy number values of all segments ## not greater than 20. options(sigminer.copynumber.max = 20) # Load copy number object load(system.file(&quot;extdata&quot;, &quot;toy_copynumber.RData&quot;, package = &quot;sigminer&quot;, mustWork = TRUE )) # Use method designed by Wang, Shixiang et al. cn_tally_W &lt;- sig_tally(cn, method = &quot;W&quot;) # Use method designed by Macintyre et al. cn_tally_M &lt;- sig_tally(cn, method = &quot;M&quot;) You can set options(sigminer.sex = \"male\", sigminer.copynumber.max = 20) at the top of your code to avoid setting them in two places. Of note, the sigminer.copynumber.max option only has effect on sig_tally() with method “W” or “M”, the sigminer.sex option has effects on read_copynumber() and sig_tally() with method “W” or “M”. This step return a list containing information about copy number features, components and matrix for NMF etc. 3.4 Extract Signatures When you get the matrix, you can just do the signature extraction as SBS signatures (see chapter Chapter 2). So here we won’t talk much. cn_tally_W$nmf_matrix[1:5, 1:5] #&gt; BP10MB[0] BP10MB[1] BP10MB[2] BP10MB[3] BP10MB[4] #&gt; TCGA-05-4417-01A-22D-1854-01 275 20 5 0 0 #&gt; TCGA-06-0644-01A-02D-0310-01 289 5 4 0 1 #&gt; TCGA-19-2621-01B-01D-0911-01 294 2 3 1 0 #&gt; TCGA-26-6174-01A-21D-1842-01 288 4 7 1 0 #&gt; TCGA-99-7458-01A-11D-2035-01 284 9 5 1 1 # library(NMF) sig_w &lt;- sig_extract(cn_tally_W$nmf_matrix, n_sig = 2, pConstant = 1e-13) References "],
["sigfit.html", "Chapter 4 Signature Fit: Sample Signature Exposure Quantification and Analysis 4.1 Fit Signatures from reference databases 4.2 Fit Custom Signatures 4.3 Performance Comparison 4.4 Estimate Exposure Stability by Bootstrap", " Chapter 4 Signature Fit: Sample Signature Exposure Quantification and Analysis Besides de novo signature discovery shown in previous chapters, another common task is that you have gotten some reference signatures (either from known database like COSMIC or de novo discovery step), you want to know how these signatures contribute (fit) in a sample. That’s the target of sig_fit(). sig_fit() uses multiple methods to compute exposure of pre-defined signatures from the spectrum of a (can be more) sample. Use ?sig_fit see more detail. To show how this function works, we use a sample with maximum mutation counts as example data. i &lt;- which.max(apply(mt_tally$nmf_matrix, 1, sum)) example_mat &lt;- mt_tally$nmf_matrix[i, , drop = FALSE] %&gt;% t() head(example_mat) #&gt; TCGA-A8-A09G-01A-21W-A019-09 #&gt; A[T&gt;C]A 1 #&gt; C[T&gt;C]A 0 #&gt; G[T&gt;C]A 1 #&gt; T[T&gt;C]A 1 #&gt; A[C&gt;T]A 5 #&gt; C[C&gt;T]A 3 4.1 Fit Signatures from reference databases For SBS signatures, users may want to directly use reference signatures from COSMIC database. sig_fit(example_mat, sig_index = 1:30) #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Started. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Signature index detected. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking signature database in package. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking signature index. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Valid index for db &#39;legacy&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #&gt; [32m✓[39m [2020-10-09 00:03:19]: Database and index checked. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Signature normalized. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking row number for catalog matrix and signature matrix. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Checked. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking rownames for catalog matrix and signature matrix. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Matrix V and W don&#39;t have same orders. Try reordering... #&gt; [32m✓[39m [2020-10-09 00:03:19]: Checked. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Method &#39;QP&#39; detected. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Corresponding function generated. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Calling function. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Generating output signature exposures. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: 0.038 secs elapsed. #&gt; TCGA-A8-A09G-01A-21W-A019-09 #&gt; COSMIC_1 24.215933 #&gt; COSMIC_2 127.164108 #&gt; COSMIC_3 0.000000 #&gt; COSMIC_4 0.000000 #&gt; COSMIC_5 0.000000 #&gt; COSMIC_6 0.000000 #&gt; COSMIC_7 4.907674 #&gt; COSMIC_8 0.000000 #&gt; COSMIC_9 0.000000 #&gt; COSMIC_10 3.584276 #&gt; COSMIC_11 0.000000 #&gt; COSMIC_12 11.062526 #&gt; COSMIC_13 168.298139 #&gt; COSMIC_14 0.000000 #&gt; COSMIC_15 0.000000 #&gt; COSMIC_16 0.000000 #&gt; COSMIC_17 5.578495 #&gt; COSMIC_18 0.000000 #&gt; COSMIC_19 0.000000 #&gt; COSMIC_20 0.000000 #&gt; COSMIC_21 0.000000 #&gt; COSMIC_22 0.000000 #&gt; COSMIC_23 0.000000 #&gt; COSMIC_24 12.084656 #&gt; COSMIC_25 0.000000 #&gt; COSMIC_26 0.000000 #&gt; COSMIC_27 0.000000 #&gt; COSMIC_28 0.000000 #&gt; COSMIC_29 0.000000 #&gt; COSMIC_30 0.104192 At default, COSMIC v2 signature database with 30 reference signatures is used (i.e. sig_db = \"legacy\"). Set sig_db = \"SBS\" for COSMIC v3 signature database. That’s it! You can set type = \"relative\" for getting relative exposure. sig_fit(example_mat, sig_index = 1:30, type = &quot;relative&quot;) #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Started. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Signature index detected. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking signature database in package. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking signature index. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Valid index for db &#39;legacy&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #&gt; [32m✓[39m [2020-10-09 00:03:19]: Database and index checked. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Signature normalized. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking row number for catalog matrix and signature matrix. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Checked. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking rownames for catalog matrix and signature matrix. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Matrix V and W don&#39;t have same orders. Try reordering... #&gt; [32m✓[39m [2020-10-09 00:03:19]: Checked. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Method &#39;QP&#39; detected. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Corresponding function generated. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Calling function. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Generating output signature exposures. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: 0.04 secs elapsed. #&gt; TCGA-A8-A09G-01A-21W-A019-09 #&gt; COSMIC_1 0.067832 #&gt; COSMIC_2 0.356202 #&gt; COSMIC_3 0.000000 #&gt; COSMIC_4 0.000000 #&gt; COSMIC_5 0.000000 #&gt; COSMIC_6 0.000000 #&gt; COSMIC_7 0.013747 #&gt; COSMIC_8 0.000000 #&gt; COSMIC_9 0.000000 #&gt; COSMIC_10 0.010040 #&gt; COSMIC_11 0.000000 #&gt; COSMIC_12 0.030987 #&gt; COSMIC_13 0.471423 #&gt; COSMIC_14 0.000000 #&gt; COSMIC_15 0.000000 #&gt; COSMIC_16 0.000000 #&gt; COSMIC_17 0.015626 #&gt; COSMIC_18 0.000000 #&gt; COSMIC_19 0.000000 #&gt; COSMIC_20 0.000000 #&gt; COSMIC_21 0.000000 #&gt; COSMIC_22 0.000000 #&gt; COSMIC_23 0.000000 #&gt; COSMIC_24 0.033851 #&gt; COSMIC_25 0.000000 #&gt; COSMIC_26 0.000000 #&gt; COSMIC_27 0.000000 #&gt; COSMIC_28 0.000000 #&gt; COSMIC_29 0.000000 #&gt; COSMIC_30 0.000292 For multiple samples, you can return a data.table, it can be easier to integrate with other information in R. sig_fit(t(mt_tally$nmf_matrix[1:5, ]), sig_index = 1:30, return_class = &quot;data.table&quot;, rel_threshold = 0.05) #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Started. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Signature index detected. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking signature database in package. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking signature index. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Valid index for db &#39;legacy&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #&gt; [32m✓[39m [2020-10-09 00:03:19]: Database and index checked. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Signature normalized. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking row number for catalog matrix and signature matrix. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Checked. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking rownames for catalog matrix and signature matrix. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Matrix V and W don&#39;t have same orders. Try reordering... #&gt; [32m✓[39m [2020-10-09 00:03:19]: Checked. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Method &#39;QP&#39; detected. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Corresponding function generated. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Calling function. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Generating output signature exposures. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: 0.052 secs elapsed. #&gt; sample COSMIC_1 COSMIC_2 COSMIC_3 COSMIC_4 COSMIC_5 COSMIC_6 #&gt; 1: TCGA-A1-A0SH-01A-11D-A099-09 0.000000 37.420603 13.78689 0.000000 0 12.93472 #&gt; 2: TCGA-A2-A04N-01A-11D-A10Y-09 20.039543 2.888675 0.00000 0.000000 0 0.00000 #&gt; 3: TCGA-A2-A0CP-01A-11W-A050-09 3.648658 0.000000 0.00000 7.083113 0 0.00000 #&gt; 4: TCGA-A2-A0EP-01A-52D-A22X-09 0.000000 0.000000 0.00000 2.492218 0 0.00000 #&gt; 5: TCGA-A2-A0EV-01A-11W-A050-09 6.458422 0.000000 14.83102 0.000000 0 14.78142 #&gt; COSMIC_7 COSMIC_8 COSMIC_9 COSMIC_10 COSMIC_11 COSMIC_12 COSMIC_13 COSMIC_14 COSMIC_15 #&gt; 1: 21.332013 0.00000 0 0.000000 0 0.000000 31.306430 0.000000 0.00000 #&gt; 2: 6.865345 12.11501 0 0.000000 0 0.000000 0.000000 0.000000 0.00000 #&gt; 3: 10.348536 0.00000 0 0.000000 0 0.000000 0.000000 0.000000 18.37734 #&gt; 4: 2.156319 0.00000 0 0.000000 0 1.334731 4.654227 6.728415 0.00000 #&gt; 5: 21.963952 0.00000 0 7.978962 0 0.000000 5.713563 0.000000 0.00000 #&gt; COSMIC_16 COSMIC_17 COSMIC_18 COSMIC_19 COSMIC_20 COSMIC_21 COSMIC_22 COSMIC_23 COSMIC_24 #&gt; 1: 0 0 12.007682 0 0.000000 0.000000 0 0.00000 0 #&gt; 2: 0 0 0.000000 0 7.516444 0.000000 0 0.00000 0 #&gt; 3: 0 0 4.384106 0 0.000000 0.000000 0 0.00000 0 #&gt; 4: 0 0 0.000000 0 0.000000 0.000000 0 1.26778 0 #&gt; 5: 0 0 0.000000 0 0.000000 4.311951 0 0.00000 0 #&gt; COSMIC_25 COSMIC_26 COSMIC_27 COSMIC_28 COSMIC_29 COSMIC_30 #&gt; 1: 0 0 0 0 0.000000 0 #&gt; 2: 0 0 0 0 0.000000 0 #&gt; 3: 0 0 0 0 4.776321 0 #&gt; 4: 0 0 0 0 0.000000 0 #&gt; 5: 0 0 0 0 0.000000 0 When you set multiple signatures, we recommend setting rel_threshold option, which will set exposure of a signature to 0 if its relative exposure in a sample less than the rel_threshold. 4.2 Fit Custom Signatures We have already determined the SBS signatures before. Here we can set them to sig option. sig_fit(example_mat, sig = mt_sig2) #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Started. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Signature index not detected. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Signature object detected. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Database and index checked. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Signature normalized. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking row number for catalog matrix and signature matrix. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Checked. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking rownames for catalog matrix and signature matrix. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Checked. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Method &#39;QP&#39; detected. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Corresponding function generated. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Calling function. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Generating output signature exposures. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: 0.033 secs elapsed. #&gt; TCGA-A8-A09G-01A-21W-A019-09 #&gt; Sig1 0 #&gt; Sig2 0 #&gt; Sig3 357 4.3 Performance Comparison Now that we can use sig_fit for getting optimal exposures, we can compare the RSS between raw matrix and the reconstructed matrix either by NMF and sig_fit(). i.e. \\[ RSS = \\sum(\\hat H - H)^2 \\] ## Exposure got from NMF sum((apply(mt_sig2$Signature, 2, function(x) x / sum(x)) %*% mt_sig2$Exposure - t(mt_tally$nmf_matrix))^2) #&gt; [1] 8891.978 ## Exposure optimized by sig_fit H_estimate &lt;- apply(mt_sig2$Signature, 2, function(x) x / sum(x)) %*% sig_fit(t(mt_tally$nmf_matrix), sig = mt_sig2) #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Started. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Signature index not detected. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Signature object detected. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Database and index checked. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Signature normalized. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking row number for catalog matrix and signature matrix. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Checked. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Checking rownames for catalog matrix and signature matrix. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Checked. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Method &#39;QP&#39; detected. #&gt; [32m✓[39m [2020-10-09 00:03:19]: Corresponding function generated. #&gt; [36mℹ[39m [2020-10-09 00:03:19]: Calling function. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Generating output signature exposures. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: 0.036 secs elapsed. H_estimate &lt;- apply(H_estimate, 2, function(x) ifelse(is.nan(x), 0, x)) H_real &lt;- t(mt_tally$nmf_matrix) sum((H_estimate - H_real)^2) #&gt; [1] 8242.63 4.4 Estimate Exposure Stability by Bootstrap This feature is based on sig_fit(), it uses the resampling data of original input and runs sig_fit() multiple times to estimate the exposure. Bootstrap replicates &gt;= 100 is recommended, here I just use 10 times for illustration. bt_result &lt;- sig_fit_bootstrap_batch(example_mat, sig = mt_sig2, n = 10) #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Batch Bootstrap Signature Exposure Analysis Started. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Samples to be filtered out: #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Finding optimal exposures (&amp;errors) for different methods. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Calling method `QP`. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Started. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Signature index not detected. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Signature object detected. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Database and index checked. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Signature normalized. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Checking row number for catalog matrix and signature matrix. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Checked. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Checking rownames for catalog matrix and signature matrix. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Checked. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Method &#39;QP&#39; detected. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Corresponding function generated. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Calling function. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Generating output signature exposures. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Calculating errors (Frobenius Norm). #&gt; [32m✓[39m [2020-10-09 00:03:20]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: 0.044 secs elapsed. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Getting bootstrap exposures (&amp;errors/similarity) for different methods. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: This step is time consuming, please be patient. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Processing sample `TCGA-A8-A09G-01A-21W-A019-09`. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Started. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: Checking catalog. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: About to start bootstrap. #&gt; → Bootstrapping 10 times. → Total 10 times, starting no.1. → Total 10 times, starting no.2. → Total 10 times, starting no.3. → Total 10 times, starting no.4. → Total 10 times, starting no.5. → Total 10 times, starting no.6. → Total 10 times, starting no.7. → Total 10 times, starting no.8. → Total 10 times, starting no.9. → Total 10 times, starting no.10. [32m✓[39m [2020-10-09 00:03:20]: Bootstrap done. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Signature exposures collected. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Errors and similarity collected. #&gt; [32m✓[39m [2020-10-09 00:03:20]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:20]: 0.73 secs elapsed. #&gt; [32m✓[39m [2020-10-09 00:03:21]: Gotten. #&gt; [36mℹ[39m [2020-10-09 00:03:21]: Reporting p values... #&gt; [36mℹ[39m [2020-10-09 00:03:21]: Started. #&gt; [32m✓[39m [2020-10-09 00:03:21]: Batch mode enabled. #&gt; [32m✓[39m [2020-10-09 00:03:21]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:21]: 0.008 secs elapsed. #&gt; [32m✓[39m [2020-10-09 00:03:21]: Done. #&gt; [36mℹ[39m [2020-10-09 00:03:21]: Cleaning results... #&gt; [32m✓[39m [2020-10-09 00:03:21]: Outputing. #&gt; [36mℹ[39m [2020-10-09 00:03:21]: Total 1.513 secs elapsed. bt_result #&gt; $expo #&gt; method sample sig exposure type #&gt; 1: QP TCGA-A8-A09G-01A-21W-A019-09 Sig1 0.000000 optimal #&gt; 2: QP TCGA-A8-A09G-01A-21W-A019-09 Sig2 0.000000 optimal #&gt; 3: QP TCGA-A8-A09G-01A-21W-A019-09 Sig3 357.000000 optimal #&gt; 4: QP TCGA-A8-A09G-01A-21W-A019-09 Sig1 0.946289 Rep_1 #&gt; 5: QP TCGA-A8-A09G-01A-21W-A019-09 Sig2 0.000000 Rep_1 #&gt; 6: QP TCGA-A8-A09G-01A-21W-A019-09 Sig3 356.053711 Rep_1 #&gt; 7: QP TCGA-A8-A09G-01A-21W-A019-09 Sig1 0.000000 Rep_2 #&gt; 8: QP TCGA-A8-A09G-01A-21W-A019-09 Sig2 0.665703 Rep_2 #&gt; 9: QP TCGA-A8-A09G-01A-21W-A019-09 Sig3 356.334297 Rep_2 #&gt; 10: QP TCGA-A8-A09G-01A-21W-A019-09 Sig1 4.827506 Rep_3 #&gt; 11: QP TCGA-A8-A09G-01A-21W-A019-09 Sig2 1.975564 Rep_3 #&gt; 12: QP TCGA-A8-A09G-01A-21W-A019-09 Sig3 350.196930 Rep_3 #&gt; 13: QP TCGA-A8-A09G-01A-21W-A019-09 Sig1 0.000000 Rep_4 #&gt; 14: QP TCGA-A8-A09G-01A-21W-A019-09 Sig2 17.364027 Rep_4 #&gt; 15: QP TCGA-A8-A09G-01A-21W-A019-09 Sig3 339.635973 Rep_4 #&gt; 16: QP TCGA-A8-A09G-01A-21W-A019-09 Sig1 0.000000 Rep_5 #&gt; 17: QP TCGA-A8-A09G-01A-21W-A019-09 Sig2 0.000000 Rep_5 #&gt; 18: QP TCGA-A8-A09G-01A-21W-A019-09 Sig3 357.000000 Rep_5 #&gt; 19: QP TCGA-A8-A09G-01A-21W-A019-09 Sig1 0.000000 Rep_6 #&gt; 20: QP TCGA-A8-A09G-01A-21W-A019-09 Sig2 13.144174 Rep_6 #&gt; 21: QP TCGA-A8-A09G-01A-21W-A019-09 Sig3 343.855826 Rep_6 #&gt; 22: QP TCGA-A8-A09G-01A-21W-A019-09 Sig1 0.000000 Rep_7 #&gt; 23: QP TCGA-A8-A09G-01A-21W-A019-09 Sig2 0.000000 Rep_7 #&gt; 24: QP TCGA-A8-A09G-01A-21W-A019-09 Sig3 357.000000 Rep_7 #&gt; 25: QP TCGA-A8-A09G-01A-21W-A019-09 Sig1 0.000000 Rep_8 #&gt; 26: QP TCGA-A8-A09G-01A-21W-A019-09 Sig2 0.725801 Rep_8 #&gt; 27: QP TCGA-A8-A09G-01A-21W-A019-09 Sig3 356.274199 Rep_8 #&gt; 28: QP TCGA-A8-A09G-01A-21W-A019-09 Sig1 1.815610 Rep_9 #&gt; 29: QP TCGA-A8-A09G-01A-21W-A019-09 Sig2 0.000000 Rep_9 #&gt; 30: QP TCGA-A8-A09G-01A-21W-A019-09 Sig3 355.184390 Rep_9 #&gt; 31: QP TCGA-A8-A09G-01A-21W-A019-09 Sig1 5.396253 Rep_10 #&gt; 32: QP TCGA-A8-A09G-01A-21W-A019-09 Sig2 0.000000 Rep_10 #&gt; 33: QP TCGA-A8-A09G-01A-21W-A019-09 Sig3 351.603747 Rep_10 #&gt; method sample sig exposure type #&gt; #&gt; $error #&gt; method sample errors type #&gt; 1: QP TCGA-A8-A09G-01A-21W-A019-09 18.549 optimal #&gt; 2: QP TCGA-A8-A09G-01A-21W-A019-09 18.569 Rep_1 #&gt; 3: QP TCGA-A8-A09G-01A-21W-A019-09 18.562 Rep_2 #&gt; 4: QP TCGA-A8-A09G-01A-21W-A019-09 18.802 Rep_3 #&gt; 5: QP TCGA-A8-A09G-01A-21W-A019-09 19.852 Rep_4 #&gt; 6: QP TCGA-A8-A09G-01A-21W-A019-09 18.549 Rep_5 #&gt; 7: QP TCGA-A8-A09G-01A-21W-A019-09 19.357 Rep_6 #&gt; 8: QP TCGA-A8-A09G-01A-21W-A019-09 18.549 Rep_7 #&gt; 9: QP TCGA-A8-A09G-01A-21W-A019-09 18.563 Rep_8 #&gt; 10: QP TCGA-A8-A09G-01A-21W-A019-09 18.592 Rep_9 #&gt; 11: QP TCGA-A8-A09G-01A-21W-A019-09 18.733 Rep_10 #&gt; #&gt; $cosine #&gt; method sample cosine type #&gt; 1: QP TCGA-A8-A09G-01A-21W-A019-09 0.988326 optimal #&gt; 2: QP TCGA-A8-A09G-01A-21W-A019-09 0.984054 Rep_1 #&gt; 3: QP TCGA-A8-A09G-01A-21W-A019-09 0.970861 Rep_2 #&gt; 4: QP TCGA-A8-A09G-01A-21W-A019-09 0.975965 Rep_3 #&gt; 5: QP TCGA-A8-A09G-01A-21W-A019-09 0.986422 Rep_4 #&gt; 6: QP TCGA-A8-A09G-01A-21W-A019-09 0.980611 Rep_5 #&gt; 7: QP TCGA-A8-A09G-01A-21W-A019-09 0.973734 Rep_6 #&gt; 8: QP TCGA-A8-A09G-01A-21W-A019-09 0.977018 Rep_7 #&gt; 9: QP TCGA-A8-A09G-01A-21W-A019-09 0.980199 Rep_8 #&gt; 10: QP TCGA-A8-A09G-01A-21W-A019-09 0.979075 Rep_9 #&gt; 11: QP TCGA-A8-A09G-01A-21W-A019-09 0.976375 Rep_10 #&gt; #&gt; $p_val #&gt; sample method threshold sig p_value #&gt; 1: TCGA-A8-A09G-01A-21W-A019-09 QP 0.05 Sig1 1 #&gt; 2: TCGA-A8-A09G-01A-21W-A019-09 QP 0.05 Sig2 1 #&gt; 3: TCGA-A8-A09G-01A-21W-A019-09 QP 0.05 Sig3 0 You can plot the result very easily with functions provided by sigminer. show_sig_bootstrap_exposure(bt_result, sample = &quot;TCGA-A8-A09G-01A-21W-A019-09&quot;) #&gt; [36mℹ[39m [2020-10-09 00:03:21]: Started. #&gt; [36mℹ[39m [2020-10-09 00:03:21]: Plotting. #&gt; [36mℹ[39m [2020-10-09 00:03:21]: 0.027 secs elapsed. show_sig_bootstrap_error(bt_result, sample = &quot;TCGA-A8-A09G-01A-21W-A019-09&quot;) #&gt; [36mℹ[39m [2020-10-09 00:03:21]: Started. #&gt; [36mℹ[39m [2020-10-09 00:03:21]: Plotting. #&gt; [36mℹ[39m [2020-10-09 00:03:21]: 0.025 secs elapsed. show_sig_bootstrap_stability(bt_result) #&gt; [36mℹ[39m [2020-10-09 00:03:21]: Started. #&gt; [36mℹ[39m [2020-10-09 00:03:21]: Plotting. #&gt; [36mℹ[39m [2020-10-09 00:03:21]: 0.036 secs elapsed. P values have been calculated under specified relative exposure cutoff (0.05 at default). The result indicates Sig3 is very stable. "],
["subtyping.html", "Chapter 5 Subtype Prediction", " Chapter 5 Subtype Prediction To expand the power of signatures to clinical application, based on signature discovery and signature fitting workflows, we can go further build neutral network model prediction model with keras. This feature is currently experimental and implemented in sigminer’s child package sigminer.prediction. "],
["sigflow.html", "Chapter 6 Sigflow Pipeline 6.1 Cancer type specific signature index database", " Chapter 6 Sigflow Pipeline Sigflow provides useful mutational signature analysis workflows based on R package sigminer. It can auto-extract mutational signatures, fit mutation data to COSMIC reference signatures (SBS/DBS/INDEL) and run bootstrapping analysis for signature fitting. For full documentation, please read Sigflow README. 6.1 Cancer type specific signature index database Signature fitting analysis may befit from directly specifying known signatures identified in a cancer type. We collect such information and provide the following data tables. db1 &lt;- system.file(&quot;extdata&quot;, &quot;cosmic2_record_by_cancer.rds&quot;, package = &quot;sigminer&quot;) db1 &lt;- readRDS(db1) colnames(db1) &lt;- c(&quot;Cancer type&quot;, &quot;Signature Index&quot;) db2 &lt;- system.file(&quot;extdata&quot;, &quot;signature_record_by_cancer.rds&quot;, package = &quot;sigminer&quot;) db2 &lt;- readRDS(db2) colnames(db2) &lt;- c( &quot;Cancer type&quot;, &quot;Cohort&quot;, &quot;Sequencing strategy&quot;, &quot;SBS signature index&quot;, &quot;DBS signature index&quot;, &quot;ID signature index&quot; ) DT::datatable(db1, caption = &quot;Data source: https://cancer.sanger.ac.uk/signatures_v2/matrix.png&quot;) Note, set sig_db to ‘legacy’ (the default) in sig_fit() family functions. DT::datatable(db2[, c(1:3, 4)], caption = &quot;Data source: Alexandrov et al. https://www.nature.com/articles/s41586-020-1943-3&quot;) DT::datatable(db2[, c(1:3, 5)], caption = &quot;Data source: Alexandrov et al. https://www.nature.com/articles/s41586-020-1943-3&quot;) DT::datatable(db2[, c(1:3, 6)], caption = &quot;Data source: Alexandrov et al. https://www.nature.com/articles/s41586-020-1943-3&quot;) "],
["cnobject.html", "Chapter 7 CopyNumber Object 7.1 Profile 7.2 Distribution", " Chapter 7 CopyNumber Object 7.1 Profile show_cn_profile(cn, nrow = 2, ncol = 1) show_cn_circos(cn, samples = 1) 7.2 Distribution show_cn_distribution(cn, mode = &quot;ld&quot;) show_cn_distribution(cn, mode = &quot;cd&quot;) "],
["sigobject.html", "Chapter 8 Signature Object 8.1 Signature Profile 8.2 Exposure Profile 8.3 Consensus Map 8.4 Catalogue Profile", " Chapter 8 Signature Object Signature is a core object in sigminer, it stores signatures and their exposures. Here we show how to plot signature profile and exposure profile. The result plots are basically ggplot based, so they can be further edited by your custom operations with ggplot grammar. 8.1 Signature Profile A signature is composed of distinct component patterns. They can be shown by show_sig_profile(). Of note, for different types of signature, the bar heights may have different meanings. SBS signatures are displayed based on the observed component frequency of the human genome, i.e., representing the relative proportions of mutations generated by each signature based on the actual trinucleotide frequencies of the reference human genome. Similar to SBS signatures, copy number signatures are displayed based on the observed component frequency of the human genome. Of note, considering the count process of each feature is relatively independent, the profile is row normalized by each feature, unlike Macintyre et al. (2018) did column normalization (this method is easy to mislead readers), so the bar height can be compared within/between features. 8.1.1 SBS Signature profile show_sig_profile(mt_sig, mode = &quot;SBS&quot;, paint_axis_text = FALSE, x_label_angle = 90) show_sig_profile(mt_sig, mode = &quot;SBS&quot;, style = &quot;cosmic&quot;, x_label_angle = 90) 8.1.2 Copy Number Signature Porfile For copy number signatures from tally method “W”, you have to specify the normalize option as “feature”, so the bar heights can be more clearly compared. show_sig_profile(sig_w, mode = &quot;copynumber&quot;, normalize = &quot;feature&quot;, method = &quot;W&quot;, style = &quot;cosmic&quot; ) 8.1.3 COSMIC Signature Profile Users can show profile of COSMIC signatures by show_cosmic_sig_profile(). To see valid signature numbers, run show_cosmic_sig_profile(sig_db = &quot;legacy&quot;) #&gt; #&gt; Valid index for db &#39;legacy&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ‘legacy’ is for COSMIC v2. show_cosmic_sig_profile(sig_db = &quot;SBS&quot;) #&gt; #&gt; Valid index for db &#39;SBS&#39;: #&gt; 1 2 3 4 5 6 7a 7b 7c 7d 8 9 10a 10b 11 12 13 14 15 16 17a 17b 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 84 85 To show the plot, specify signature shortnames to sig_index option. show_cosmic_sig_profile(sig_index = c(1, 5, 6), style = &quot;cosmic&quot;) #&gt; #&gt; Valid index for db &#39;legacy&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 show_cosmic_sig_profile(sig_index = c(1, 2, 3), style = &quot;cosmic&quot;, sig_db = &quot;DBS&quot;) #&gt; #&gt; Valid index for db &#39;DBS&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 show_cosmic_sig_profile(sig_index = c(4, 5, 6), style = &quot;cosmic&quot;, sig_db = &quot;ID&quot;) #&gt; #&gt; Valid index for db &#39;ID&#39;: #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 8.2 Exposure Profile show_sig_exposure(mt_sig) show_sig_exposure(mt_sig, style = &quot;cosmic&quot;) show_sig_exposure(sig_w, style = &quot;cosmic&quot;) You can put group labels in the exposure profile. grp &lt;- get_groups(sig_w) #&gt; [36mℹ[39m [2020-10-09 00:03:40]: Started. #&gt; [32m✓[39m [2020-10-09 00:03:40]: &#39;Signature&#39; object detected. #&gt; [36mℹ[39m [2020-10-09 00:03:40]: Obtaining clusters from the hierarchical clustering of the consensus matrix... #&gt; [36mℹ[39m [2020-10-09 00:03:40]: Finding the dominant signature of each group... #&gt; =&gt; Generating a table of group and dominant signature: #&gt; #&gt; Sig1 Sig2 #&gt; 1 0 2 #&gt; 2 8 0 #&gt; =&gt; Assigning a group to a signature with the maxium fraction (stored in &#39;map_table&#39; attr)... #&gt; [36mℹ[39m [2020-10-09 00:03:40]: Summarizing... #&gt; group #1: 2 samples with Sig2 enriched. #&gt; group #2: 8 samples with Sig1 enriched. #&gt; [33m![39m [2020-10-09 00:03:40]: The &#39;enrich_sig&#39; column is set to dominant signature in one group, please check and make it consistent with biological meaning (correct it by hand if necessary). #&gt; [36mℹ[39m [2020-10-09 00:03:40]: 0.043 secs elapsed. grp_label &lt;- grp$group names(grp_label) &lt;- grp$sample show_sig_exposure(sig_w, style = &quot;cosmic&quot;, groups = grp_label) Of note: For COSMIC signatures, the absolute exposure is the estimated mutation counts. For copy number signatures, the absolute exposure is the estimated copy number segments. 8.3 Consensus Map This can only support the result from sig_extract() with multiple runs. show_sig_consensusmap(mt_sig) 8.4 Catalogue Profile Based on plot method for signature, we can plot raw catalogue profile. show_catalogue(t(mt_tally$nmf_matrix), style = &quot;cosmic&quot;, x_label_angle = 90) At default, the function sums all samples. Users can specify sample ID. show_catalogue(t(mt_tally$nmf_matrix), style = &quot;cosmic&quot;, samples = &quot;TCGA-E9-A22E-01A-11D-A159-09&quot;, x_label_angle = 90) "],
["association-analysis.html", "Chapter 9 Association Analysis and Visualization 9.1 General numeric association 9.2 Comprehensive association", " Chapter 9 Association Analysis and Visualization 9.1 General numeric association For general numeric association, you can use show_cor() function. data(&quot;mtcars&quot;) p1 &lt;- show_cor(mtcars) p2 &lt;- show_cor(mtcars, x_vars = colnames(mtcars)[1:4], y_vars = colnames(mtcars)[5:8] ) p3 &lt;- show_cor(mtcars, vis_method = &quot;circle&quot;, p_adj = &quot;fdr&quot;) p1 p1$cor #&gt; $cor_mat #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; mpg 1.00 -0.91 -0.91 -0.89 0.65 -0.89 0.47 0.71 0.56 0.54 -0.66 #&gt; cyl -0.91 1.00 0.93 0.90 -0.68 0.86 -0.57 -0.81 -0.52 -0.56 0.58 #&gt; disp -0.91 0.93 1.00 0.85 -0.68 0.90 -0.46 -0.72 -0.62 -0.59 0.54 #&gt; hp -0.89 0.90 0.85 1.00 -0.52 0.77 -0.67 -0.75 -0.36 -0.33 0.73 #&gt; drat 0.65 -0.68 -0.68 -0.52 1.00 -0.75 0.09 0.45 0.69 0.74 -0.13 #&gt; wt -0.89 0.86 0.90 0.77 -0.75 1.00 -0.23 -0.59 -0.74 -0.68 0.50 #&gt; qsec 0.47 -0.57 -0.46 -0.67 0.09 -0.23 1.00 0.79 -0.20 -0.15 -0.66 #&gt; vs 0.71 -0.81 -0.72 -0.75 0.45 -0.59 0.79 1.00 0.17 0.28 -0.63 #&gt; am 0.56 -0.52 -0.62 -0.36 0.69 -0.74 -0.20 0.17 1.00 0.81 -0.06 #&gt; gear 0.54 -0.56 -0.59 -0.33 0.74 -0.68 -0.15 0.28 0.81 1.00 0.11 #&gt; carb -0.66 0.58 0.54 0.73 -0.13 0.50 -0.66 -0.63 -0.06 0.11 1.00 #&gt; #&gt; $p_mat #&gt; mpg cyl disp hp drat wt qsec #&gt; mpg 0.000000e+00 6.112687e-10 9.380327e-10 1.787835e-07 1.776240e-05 1.293959e-10 1.708199e-02 #&gt; cyl 6.112687e-10 0.000000e+00 1.802838e-12 3.477861e-09 8.244636e-06 1.217567e-07 3.660533e-04 #&gt; disp 9.380327e-10 1.802838e-12 0.000000e+00 7.142679e-08 5.282022e-06 1.222320e-11 1.314404e-02 #&gt; hp 1.787835e-07 3.477861e-09 7.142679e-08 0.000000e+00 9.988772e-03 4.145827e-05 5.766253e-06 #&gt; drat 1.776240e-05 8.244636e-06 5.282022e-06 9.988772e-03 0.000000e+00 4.784260e-06 6.195826e-01 #&gt; wt 1.293959e-10 1.217567e-07 1.222320e-11 4.145827e-05 4.784260e-06 0.000000e+00 3.388683e-01 #&gt; qsec 1.708199e-02 3.660533e-04 1.314404e-02 5.766253e-06 6.195826e-01 3.388683e-01 0.000000e+00 #&gt; vs 3.415937e-05 1.843018e-08 5.235012e-06 2.940896e-06 1.167553e-02 9.798492e-04 1.029669e-06 #&gt; am 2.850207e-04 2.151207e-03 3.662114e-04 1.798309e-01 4.726790e-06 1.125440e-05 2.056621e-01 #&gt; gear 5.400948e-03 4.173297e-03 9.635921e-04 4.930119e-01 8.360110e-06 4.586601e-04 2.425344e-01 #&gt; carb 1.084446e-03 1.942340e-03 2.526789e-02 7.827810e-07 6.211834e-01 1.463861e-02 4.536949e-05 #&gt; vs am gear carb #&gt; mpg 3.415937e-05 2.850207e-04 5.400948e-03 1.084446e-03 #&gt; cyl 1.843018e-08 2.151207e-03 4.173297e-03 1.942340e-03 #&gt; disp 5.235012e-06 3.662114e-04 9.635921e-04 2.526789e-02 #&gt; hp 2.940896e-06 1.798309e-01 4.930119e-01 7.827810e-07 #&gt; drat 1.167553e-02 4.726790e-06 8.360110e-06 6.211834e-01 #&gt; wt 9.798492e-04 1.125440e-05 4.586601e-04 1.463861e-02 #&gt; qsec 1.029669e-06 2.056621e-01 2.425344e-01 4.536949e-05 #&gt; vs 0.000000e+00 3.570439e-01 2.579439e-01 6.670496e-04 #&gt; am 3.570439e-01 0.000000e+00 5.834043e-08 7.544526e-01 #&gt; gear 2.579439e-01 5.834043e-08 0.000000e+00 1.290291e-01 #&gt; carb 6.670496e-04 7.544526e-01 1.290291e-01 0.000000e+00 p2 p3 9.2 Comprehensive association For comprehensive association analysis including both continuous and categorical variables, there are several functions available in sigminer: get_sig_feature_association(). get_tidy_association(). show_sig_feature_corrplot(). Currently, I haven’t provided a proper example dataset for showing usage of all functions above (please read their documentation), here only the tidy dataset from our study (Wang et al. 2020) is given to show the plot function. # The data is generated from Wang, Shixiang et al. load(system.file(&quot;extdata&quot;, &quot;asso_data.RData&quot;, package = &quot;sigminer&quot;, mustWork = TRUE )) p &lt;- show_sig_feature_corrplot(tidy_data.seqz.feature, p_val = 0.05) #&gt; Warning: Problem with `mutate()` input `gg`. #&gt; ℹ Using size for a discrete variable is not advised. #&gt; ℹ Input `gg` is `purrr::map2(.data$data, .data$type, .plot_cor)`. #&gt; ℹ The error occurred in group 1: type = &quot;ca&quot;. #&gt; Warning: Using size for a discrete variable is not advised. #&gt; Warning: Problem with `mutate()` input `gg`. #&gt; ℹ Using size for a discrete variable is not advised. #&gt; ℹ Input `gg` is `purrr::map2(.data$data, .data$type, .plot_cor)`. #&gt; ℹ The error occurred in group 2: type = &quot;co&quot;. #&gt; Warning: Using size for a discrete variable is not advised. p References "],
["group-analysis.html", "Chapter 10 Group Analysis and Visualization 10.1 Group Generation 10.2 Group Comparison Analysis 10.3 Group Visualization", " Chapter 10 Group Analysis and Visualization Group analysis is a common task in cancer study. Sigminer supports dividing samples into multiple groups and comparing genotype/phenotype feature measures. 10.1 Group Generation There are multiple methods to generate groups, including ‘consensus’ (default, can be only used by result from sig_extract()), ‘k-means’ etc. After determining groups, sigminer will assign each group to a signature with maximum fraction. We may say a group is Sig_x enriched. mt_grps &lt;- get_groups(mt_sig, method = &quot;consensus&quot;, match_consensus = TRUE) #&gt; [36mℹ[39m [2020-10-09 00:03:46]: Started. #&gt; [32m✓[39m [2020-10-09 00:03:46]: &#39;Signature&#39; object detected. #&gt; [36mℹ[39m [2020-10-09 00:03:46]: Obtaining clusters from the hierarchical clustering of the consensus matrix... #&gt; [36mℹ[39m [2020-10-09 00:03:46]: Finding the dominant signature of each group... #&gt; =&gt; Generating a table of group and dominant signature: #&gt; #&gt; Sig1 Sig2 Sig3 Sig4 Sig5 #&gt; 1 14 0 0 0 0 #&gt; 2 0 2 4 0 0 #&gt; 3 1 0 8 15 0 #&gt; 4 0 2 0 0 8 #&gt; 5 0 42 3 1 0 #&gt; =&gt; Assigning a group to a signature with the maxium fraction (stored in &#39;map_table&#39; attr)... #&gt; [36mℹ[39m [2020-10-09 00:03:46]: Summarizing... #&gt; group #1: 14 samples with Sig1 enriched. #&gt; group #2: 6 samples with Sig3 enriched. #&gt; group #3: 24 samples with Sig4 enriched. #&gt; group #4: 10 samples with Sig5 enriched. #&gt; group #5: 46 samples with Sig2 enriched. #&gt; [33m![39m [2020-10-09 00:03:46]: The &#39;enrich_sig&#39; column is set to dominant signature in one group, please check and make it consistent with biological meaning (correct it by hand if necessary). #&gt; [36mℹ[39m [2020-10-09 00:03:46]: 0.088 secs elapsed. head(mt_grps) #&gt; sample group silhouette_width enrich_sig #&gt; 1: TCGA-PE-A5DD-01A-12D-A27P-09 1 0.572 Sig1 #&gt; 2: TCGA-D8-A1JJ-01A-31D-A14K-09 1 0.279 Sig1 #&gt; 3: TCGA-BH-A18K-01A-11D-A12B-09 1 0.125 Sig1 #&gt; 4: TCGA-AC-A2FO-01A-11D-A17W-09 1 0.259 Sig1 #&gt; 5: TCGA-E2-A1IH-01A-11D-A188-09 1 0.535 Sig1 #&gt; 6: TCGA-E2-A152-01A-11D-A12B-09 1 0.482 Sig1 The returned sample orders match sample orders in clustered consensus matrix. show_sig_consensusmap(mt_sig) Sometimes, the mapping between groups and enriched signatures may not right. Users should check it and even correct it manually. attr(mt_grps, &quot;map_table&quot;) #&gt; #&gt; Sig1 Sig2 Sig3 Sig4 Sig5 #&gt; 1 14 0 0 0 0 #&gt; 2 0 2 4 0 0 #&gt; 3 1 0 8 15 0 #&gt; 4 0 2 0 0 8 #&gt; 5 0 42 3 1 0 10.2 Group Comparison Analysis load(system.file(&quot;extdata&quot;, &quot;toy_copynumber_signature_by_M.RData&quot;, package = &quot;sigminer&quot;, mustWork = TRUE )) # Assign samples to clusters groups &lt;- get_groups(sig, method = &quot;k-means&quot;) #&gt; [36mℹ[39m [2020-10-09 00:03:46]: Started. #&gt; [32m✓[39m [2020-10-09 00:03:46]: &#39;Signature&#39; object detected. #&gt; [36mℹ[39m [2020-10-09 00:03:46]: Running k-means with 2 clusters... #&gt; [36mℹ[39m [2020-10-09 00:03:46]: Generating a table of group and signature contribution (stored in &#39;map_table&#39; attr): #&gt; Sig1 Sig2 #&gt; 1 0.003428449 0.9965716 #&gt; 2 0.031799383 0.9682006 #&gt; [36mℹ[39m [2020-10-09 00:03:46]: Assigning a group to a signature with the maximum fraction... #&gt; [36mℹ[39m [2020-10-09 00:03:46]: Summarizing... #&gt; group #1: 6 samples with Sig2 enriched. #&gt; group #2: 4 samples with Sig2 enriched. #&gt; [33m![39m [2020-10-09 00:03:46]: The &#39;enrich_sig&#39; column is set to dominant signature in one group, please check and make it consistent with biological meaning (correct it by hand if necessary). #&gt; [36mℹ[39m [2020-10-09 00:03:46]: 0.042 secs elapsed. set.seed(1234) groups$prob &lt;- rnorm(10) groups$new_group &lt;- sample(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, NA), size = nrow(groups), replace = TRUE) # Compare groups (filter NAs for categorical coloumns) groups.cmp &lt;- get_group_comparison(groups[, -1], col_group = &quot;group&quot;, cols_to_compare = c(&quot;prob&quot;, &quot;new_group&quot;), type = c(&quot;co&quot;, &quot;ca&quot;), verbose = TRUE ) #&gt; Treat prob as continuous variable. #&gt; Treat new_group as categorical variable. # Compare groups (Set NAs of categorical columns to &#39;Rest&#39;) groups.cmp2 &lt;- get_group_comparison(groups[, -1], col_group = &quot;group&quot;, cols_to_compare = c(&quot;prob&quot;, &quot;new_group&quot;), type = c(&quot;co&quot;, &quot;ca&quot;), NAs = &quot;Rest&quot;, verbose = TRUE ) #&gt; Treat prob as continuous variable. #&gt; Treat new_group as categorical variable. 10.3 Group Visualization ggcomp &lt;- show_group_comparison(groups.cmp2) ggcomp$co_comb ggcomp$ca_comb "],
["datasets.html", "Chapter 11 Datasets 11.1 Reference Annotation 11.2 Copy Number components setting", " Chapter 11 Datasets 11.1 Reference Annotation sigminer stores many reference annotation datasets for internal calculation. It can be exported for other usage either by data() or get_genome_annotation(). Currently, there are the following datasets: centromeres.hg19 centromeres.hg38 chromsize.hg19 chromsize.hg38 cytobands.hg19 cytobands.hg38 An example is given as below: data(&quot;centromeres.hg19&quot;) head(centromeres.hg19) #&gt; chrom left.base right.base #&gt; 1 chr1 121535434 124535434 #&gt; 2 chr2 92326171 95326171 #&gt; 3 chr3 90504854 93504854 #&gt; 4 chr4 49660117 52660117 #&gt; 5 chr5 46405641 49405641 #&gt; 6 chr6 58830166 61830166 get_genome_annotation() can better control the returned data.frame. get_genome_annotation( data_type = &quot;chr_size&quot;, chrs = c(&quot;chr1&quot;, &quot;chr10&quot;, &quot;chr20&quot;), genome_build = &quot;hg19&quot; ) #&gt; chrom size #&gt; 1 chr1 249250621 #&gt; 2 chr10 135534747 #&gt; 3 chr20 63025520 More see ?get_genome_annotation. 11.2 Copy Number components setting Dataset CN.features is a predefined component data table for identifying copy number signatures by method “Wang”. Users can define a custom table with similar structure and pass it to function like sig_tally(). Detail about how to generate this dataset can be viewed at https://github.com/ShixiangWang/sigminer/blob/master/data-raw/CN-features.R. CN.features #&gt; feature component label min max #&gt; 1: BP10MB BP10MB[0] point 0 0 #&gt; 2: BP10MB BP10MB[1] point 1 1 #&gt; 3: BP10MB BP10MB[2] point 2 2 #&gt; 4: BP10MB BP10MB[3] point 3 3 #&gt; 5: BP10MB BP10MB[4] point 4 4 #&gt; 6: BP10MB BP10MB[5] point 5 5 #&gt; 7: BP10MB BP10MB[&gt;5] range 5 Inf #&gt; 8: BPArm BPArm[0] point 0 0 #&gt; 9: BPArm BPArm[1] point 1 1 #&gt; 10: BPArm BPArm[2] point 2 2 #&gt; 11: BPArm BPArm[3] point 3 3 #&gt; 12: BPArm BPArm[4] point 4 4 #&gt; 13: BPArm BPArm[5] point 5 5 #&gt; 14: BPArm BPArm[6] point 6 6 #&gt; 15: BPArm BPArm[7] point 7 7 #&gt; 16: BPArm BPArm[8] point 8 8 #&gt; 17: BPArm BPArm[9] point 9 9 #&gt; 18: BPArm BPArm[10] point 10 10 #&gt; 19: BPArm BPArm[&gt;10 &amp; &lt;=20] range 10 20 #&gt; 20: BPArm BPArm[&gt;20 &amp; &lt;=30] range 20 30 #&gt; 21: BPArm BPArm[&gt;30] range 30 Inf #&gt; 22: CN CN[0] point 0 0 #&gt; 23: CN CN[1] point 1 1 #&gt; 24: CN CN[2] point 2 2 #&gt; 25: CN CN[3] point 3 3 #&gt; 26: CN CN[4] point 4 4 #&gt; 27: CN CN[&gt;4 &amp; &lt;=8] range 4 8 #&gt; 28: CN CN[&gt;8] range 8 Inf #&gt; 29: CNCP CNCP[0] point 0 0 #&gt; 30: CNCP CNCP[1] point 1 1 #&gt; 31: CNCP CNCP[2] point 2 2 #&gt; 32: CNCP CNCP[3] point 3 3 #&gt; 33: CNCP CNCP[4] point 4 4 #&gt; 34: CNCP CNCP[&gt;4 &amp; &lt;=8] range 4 8 #&gt; 35: CNCP CNCP[&gt;8] range 8 Inf #&gt; 36: OsCN OsCN[0] point 0 0 #&gt; 37: OsCN OsCN[1] point 1 1 #&gt; 38: OsCN OsCN[2] point 2 2 #&gt; 39: OsCN OsCN[3] point 3 3 #&gt; 40: OsCN OsCN[4] point 4 4 #&gt; 41: OsCN OsCN[&gt;4 &amp; &lt;=10] range 4 10 #&gt; 42: OsCN OsCN[&gt;10] range 10 Inf #&gt; 43: SS SS[&lt;=2] range -Inf 2 #&gt; 44: SS SS[&gt;2 &amp; &lt;=3] range 2 3 #&gt; 45: SS SS[&gt;3 &amp; &lt;=4] range 3 4 #&gt; 46: SS SS[&gt;4 &amp; &lt;=5] range 4 5 #&gt; 47: SS SS[&gt;5 &amp; &lt;=6] range 5 6 #&gt; 48: SS SS[&gt;6 &amp; &lt;=7] range 6 7 #&gt; 49: SS SS[&gt;7 &amp; &lt;=8] range 7 8 #&gt; 50: SS SS[&gt;8] range 8 Inf #&gt; 51: NC50 NC50[&lt;=2] range -Inf 2 #&gt; 52: NC50 NC50[3] point 3 3 #&gt; 53: NC50 NC50[4] point 4 4 #&gt; 54: NC50 NC50[5] point 5 5 #&gt; 55: NC50 NC50[6] point 6 6 #&gt; 56: NC50 NC50[7] point 7 7 #&gt; 57: NC50 NC50[&gt;7] range 7 Inf #&gt; 58: BoChr BoChr[1] point 1 1 #&gt; 59: BoChr BoChr[2] point 2 2 #&gt; 60: BoChr BoChr[3] point 3 3 #&gt; 61: BoChr BoChr[4] point 4 4 #&gt; 62: BoChr BoChr[5] point 5 5 #&gt; 63: BoChr BoChr[6] point 6 6 #&gt; 64: BoChr BoChr[7] point 7 7 #&gt; 65: BoChr BoChr[8] point 8 8 #&gt; 66: BoChr BoChr[9] point 9 9 #&gt; 67: BoChr BoChr[10] point 10 10 #&gt; 68: BoChr BoChr[11] point 11 11 #&gt; 69: BoChr BoChr[12] point 12 12 #&gt; 70: BoChr BoChr[13] point 13 13 #&gt; 71: BoChr BoChr[14] point 14 14 #&gt; 72: BoChr BoChr[15] point 15 15 #&gt; 73: BoChr BoChr[16] point 16 16 #&gt; 74: BoChr BoChr[17] point 17 17 #&gt; 75: BoChr BoChr[18] point 18 18 #&gt; 76: BoChr BoChr[19] point 19 19 #&gt; 77: BoChr BoChr[20] point 20 20 #&gt; 78: BoChr BoChr[21] point 21 21 #&gt; 79: BoChr BoChr[22] point 22 22 #&gt; 80: BoChr BoChr[23] point 23 23 #&gt; feature component label min max "],
["convert.html", "Chapter 12 SBS Signature Conversion", " Chapter 12 SBS Signature Conversion Converts signatures between two representations relative to different sets of mutational opportunities. Currently, only SBS signature is supported. # Load SBS signature load(system.file(&quot;extdata&quot;, &quot;toy_mutational_signature.RData&quot;, package = &quot;sigminer&quot;, mustWork = TRUE )) # Exome-relative to Genome-relative sig_converted &lt;- sig_convert(sig2, from = &quot;human-exome&quot;, to = &quot;human-genome&quot; ) sig_converted #&gt; Sig1 Sig2 Sig3 #&gt; A[C&gt;A]A 0.000000e+00 1.283652e-02 2.354578e-204 #&gt; A[C&gt;A]C 0.000000e+00 1.866572e-02 0.000000e+00 #&gt; A[C&gt;A]G 0.000000e+00 1.618700e-03 0.000000e+00 #&gt; A[C&gt;A]T 0.000000e+00 7.572233e-03 0.000000e+00 #&gt; C[C&gt;A]A 0.000000e+00 1.209076e-02 0.000000e+00 #&gt; C[C&gt;A]C 0.000000e+00 7.032249e-03 1.170400e-133 #&gt; C[C&gt;A]G 0.000000e+00 3.839313e-03 1.165310e-269 #&gt; C[C&gt;A]T 0.000000e+00 1.166974e-02 0.000000e+00 #&gt; G[C&gt;A]A 0.000000e+00 1.025669e-02 4.089543e-15 #&gt; G[C&gt;A]C 2.975389e-296 4.002311e-03 0.000000e+00 #&gt; G[C&gt;A]G 4.796114e-02 4.527374e-117 0.000000e+00 #&gt; G[C&gt;A]T 0.000000e+00 5.994876e-03 1.669814e-131 #&gt; T[C&gt;A]A 0.000000e+00 3.324941e-96 7.673114e-02 #&gt; T[C&gt;A]C 0.000000e+00 1.467589e-02 9.720402e-229 #&gt; T[C&gt;A]G 0.000000e+00 3.199454e-03 0.000000e+00 #&gt; T[C&gt;A]T 0.000000e+00 2.338506e-02 0.000000e+00 #&gt; A[C&gt;G]A 0.000000e+00 1.198076e-02 1.210238e-153 #&gt; A[C&gt;G]C 0.000000e+00 3.999796e-03 0.000000e+00 #&gt; A[C&gt;G]G 9.976549e-02 7.184837e-58 0.000000e+00 #&gt; A[C&gt;G]T 0.000000e+00 7.572233e-03 9.731662e-108 #&gt; C[C&gt;G]A 0.000000e+00 8.732217e-03 1.472610e-34 #&gt; C[C&gt;G]C 0.000000e+00 1.875266e-03 0.000000e+00 #&gt; C[C&gt;G]G 0.000000e+00 4.429976e-03 1.144811e-70 #&gt; C[C&gt;G]T 1.398527e-01 1.003533e-19 0.000000e+00 #&gt; G[C&gt;G]A 1.227107e-293 7.521572e-03 2.969058e-285 #&gt; G[C&gt;G]C 0.000000e+00 3.001734e-03 2.665595e-168 #&gt; G[C&gt;G]G 0.000000e+00 2.178881e-03 0.000000e+00 #&gt; G[C&gt;G]T 0.000000e+00 3.996584e-03 0.000000e+00 #&gt; T[C&gt;G]A 0.000000e+00 4.493267e-03 2.338585e-311 #&gt; T[C&gt;G]C 0.000000e+00 5.336688e-03 1.100445e-248 #&gt; T[C&gt;G]G 0.000000e+00 5.027714e-03 2.505791e-283 #&gt; T[C&gt;G]T 0.000000e+00 8.094828e-03 4.211703e-12 #&gt; A[C&gt;T]A 0.000000e+00 4.278842e-02 6.186711e-285 #&gt; A[C&gt;T]C 0.000000e+00 3.266500e-02 4.009287e-180 #&gt; A[C&gt;T]G 0.000000e+00 8.943317e-02 1.936180e-271 #&gt; A[C&gt;T]T 0.000000e+00 2.366323e-02 0.000000e+00 #&gt; C[C&gt;T]A 0.000000e+00 2.552494e-02 0.000000e+00 #&gt; C[C&gt;T]C 0.000000e+00 1.406450e-02 1.334078e-226 #&gt; C[C&gt;T]G 0.000000e+00 5.463637e-02 9.737288e-158 #&gt; C[C&gt;T]T 0.000000e+00 3.695418e-02 4.246509e-172 #&gt; G[C&gt;T]A 0.000000e+00 1.550033e-134 1.379990e-01 #&gt; G[C&gt;T]C 0.000000e+00 2.401387e-02 9.655208e-197 #&gt; G[C&gt;T]G 0.000000e+00 5.665090e-02 1.322415e-193 #&gt; G[C&gt;T]T 0.000000e+00 3.197267e-02 1.483309e-124 #&gt; T[C&gt;T]A 0.000000e+00 3.504749e-02 1.602583e-125 #&gt; T[C&gt;T]C 0.000000e+00 2.868470e-02 2.192251e-133 #&gt; T[C&gt;T]G 0.000000e+00 5.607061e-45 3.725237e-01 #&gt; T[C&gt;T]T 0.000000e+00 2.248563e-02 5.991874e-150 #&gt; A[T&gt;A]A 0.000000e+00 8.169022e-163 4.909543e-207 #&gt; A[T&gt;A]C 0.000000e+00 9.451235e-03 9.169290e-161 #&gt; A[T&gt;A]G 0.000000e+00 1.860257e-209 3.781700e-02 #&gt; A[T&gt;A]T 0.000000e+00 3.646724e-03 0.000000e+00 #&gt; C[T&gt;A]A 0.000000e+00 9.626354e-63 1.877035e-152 #&gt; C[T&gt;A]C 0.000000e+00 4.098575e-03 8.954807e-03 #&gt; C[T&gt;A]G 0.000000e+00 7.584736e-03 1.779246e-46 #&gt; C[T&gt;A]T 0.000000e+00 4.886651e-03 0.000000e+00 #&gt; G[T&gt;A]A 0.000000e+00 1.923466e-257 1.645056e-02 #&gt; G[T&gt;A]C 0.000000e+00 5.990275e-03 2.816093e-138 #&gt; G[T&gt;A]G 0.000000e+00 2.491146e-03 5.966918e-137 #&gt; G[T&gt;A]T 1.780073e-01 1.470587e-107 0.000000e+00 #&gt; T[T&gt;A]A 0.000000e+00 0.000000e+00 1.576605e-78 #&gt; T[T&gt;A]C 0.000000e+00 3.652510e-193 3.025830e-02 #&gt; T[T&gt;A]G 0.000000e+00 0.000000e+00 3.102984e-02 #&gt; T[T&gt;A]T 0.000000e+00 5.570191e-03 2.661350e-186 #&gt; A[T&gt;C]A 0.000000e+00 3.673499e-02 2.037390e-236 #&gt; A[T&gt;C]C 0.000000e+00 4.875997e-80 8.069896e-02 #&gt; A[T&gt;C]G 0.000000e+00 2.533400e-02 4.653276e-300 #&gt; A[T&gt;C]T 0.000000e+00 3.403610e-02 1.137147e-235 #&gt; C[T&gt;C]A 0.000000e+00 7.619558e-03 1.273356e-94 #&gt; C[T&gt;C]C 0.000000e+00 1.116095e-02 1.501723e-122 #&gt; C[T&gt;C]G 0.000000e+00 9.506418e-50 9.321794e-02 #&gt; C[T&gt;C]T 0.000000e+00 1.172796e-02 1.679251e-87 #&gt; G[T&gt;C]A 0.000000e+00 4.585040e-03 5.536247e-03 #&gt; G[T&gt;C]C 0.000000e+00 5.073564e-255 4.133148e-02 #&gt; G[T&gt;C]G 0.000000e+00 6.850650e-03 0.000000e+00 #&gt; G[T&gt;C]T 3.036787e-50 1.058999e-02 7.624782e-161 #&gt; T[T&gt;C]A 0.000000e+00 1.774320e-183 1.917769e-02 #&gt; T[T&gt;C]C 3.471970e-224 7.796288e-03 0.000000e+00 #&gt; T[T&gt;C]G 0.000000e+00 9.993850e-03 0.000000e+00 #&gt; T[T&gt;C]T 0.000000e+00 2.116673e-02 4.729625e-249 #&gt; A[T&gt;G]A 0.000000e+00 6.559820e-03 0.000000e+00 #&gt; A[T&gt;G]C 0.000000e+00 8.576821e-159 1.467254e-02 #&gt; A[T&gt;G]G 0.000000e+00 1.544237e-03 3.140069e-03 #&gt; A[T&gt;G]T 0.000000e+00 3.646724e-03 0.000000e+00 #&gt; C[T&gt;G]A 0.000000e+00 1.088508e-03 0.000000e+00 #&gt; C[T&gt;G]C 0.000000e+00 5.252213e-03 5.352907e-111 #&gt; C[T&gt;G]G 0.000000e+00 6.320613e-03 0.000000e+00 #&gt; C[T&gt;G]T 1.505897e-01 2.544085e-94 2.345935e-218 #&gt; G[T&gt;G]A 9.796461e-02 2.199487e-93 1.446688e-154 #&gt; G[T&gt;G]C 0.000000e+00 1.996758e-03 0.000000e+00 #&gt; G[T&gt;G]G 0.000000e+00 3.736718e-03 0.000000e+00 #&gt; G[T&gt;G]T 0.000000e+00 3.701349e-72 1.494581e-02 #&gt; T[T&gt;G]A 1.142049e-01 5.198170e-158 0.000000e+00 #&gt; T[T&gt;G]C 0.000000e+00 4.872680e-03 0.000000e+00 #&gt; T[T&gt;G]G 0.000000e+00 1.798724e-19 1.551492e-02 #&gt; T[T&gt;G]T 1.716541e-01 1.775134e-54 0.000000e+00 show_sig_profile(sig2, style = &quot;cosmic&quot;) show_sig_profile(sig_converted, style = &quot;cosmic&quot;) "],
["references.html", "References", " References "]
]
